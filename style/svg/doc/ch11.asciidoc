[[filters-chapter]]

== Filters

The preceding chapters have given you a basis for creating graphics that convey((("filters", id="ix_filters", range="startofrange"))) information with great precision and detail. If you’re going on a spring picnic, you want a precise map. When you look in the newspaper for the graphics that describe the weather forecast, you want “just the facts.”

If you’re asked later to describe the day of the picnic, nobody wants a crisp recitation of meteorological statistics. Similarly, nobody wants to see a graphic of a spring flower composed of pure vectors; <<unfiltered-flower-figure>> fails totally to convey any warmth or charm.

[[unfiltered-flower-figure]]

.Flower composed of plain vectors
image::images/sve2_1101.png[]

Graphics are often designed to evoke feelings or moods as much as they are meant to convey information. Artists who work with bitmap graphics--and therefore work with the _appearance_ of an object instead of its geometrical definition--have many tools at their disposal to add such effects.((("raster graphics", "and filter effects")))  They can produce blurred shadows, selectively thicken or thin lines, add textures to part of the drawing, or make an object appear to be embossed or beveled.

[[filter-overview-section]]

=== How Filters Work

Although SVG is not a bitmap description language,((("filters", "how they work"))) it still lets you use some of these same tools. When an SVG viewer program processes a graphic object, it will render the object to some bitmapped output device; at some point, the program will convert the object’s description into the appropriate set of pixels that appear on the output device. Now let’s say that you use the SVG +<filter>+ element to specify a set of operations (also called _primitives_) ((("primitives, filter")))that display an object with a blurred shadow offset slightly to the side, and attach that filter to an object:

[source,xml]
----
<filter id="drop-shadow">
  <!-- filter operations go here -->
</filter>

<g id="spring-flower"
  style="filter: url(#drop-shadow);"/>
  <!-- drawing of flower goes here -->
</g>
----

Because the flower uses a filter in its presentation style, SVG will not render the flower directly to the final graphic. Instead, SVG will render the flower’s pixels into a temporary bitmap.((("bitmaps", "temporary, filter operations on"))) The operations specified by the filter will be applied to that temporary area and their result will be rendered into the final graphic.

The size of the temporary bitmap will by default depend on the resolution and size of the display screen on which the image will be rendered.  This means that some filter effects can have different appearances at different sizes, even if all the SVG code is the same.  The http://www.w3.org/TR/SVG11/filters.html#FilterEffectsRegion[specifications define attributes to control the effective resolution of the filter effects], but((("filters", "resolution of"))) these are not consistently implemented in SVG viewers and are not discussed here.

[[drop-shadow-section]]

=== Creating a Drop Shadow

<<image-element-example>> created a drop shadow by offsetting a gray ellipse underneath a colored ellipse.((("drop shadow, creating", id="ix_dropshadow", range="startofrange")))((("filters", "creating a drop shadow"))) It worked, but it wasn’t elegant. Let’s investigate a way to create a better-looking drop shadow with a filter.

[[filter-bounds-section]]

==== Establishing the Filter’s Bounds

The +<filter>+ element has attributes that describe the clipping region for a filter.((("filters", "creating a drop shadow", "establishing filter's bounds"))) You specify an +x+, +y+, +width+, and +height+ in terms of the percentage of the filtered object’s bounding box. (That is the default.) Any portion of the resulting output that’s outside the bounds will not be displayed. If you are intending to apply a filter to many objects, you may want to omit these attributes altogether and take the default values of +x+ equal to –10%, +y+ equal to –10%, +width+ equal to 120%, and +height+ equal to 120%. This gives extra space for filters—such as the drop shadow that we’re constructing—that produce output larger than their input.

These attributes are in terms of the filtered object’s bounding box; specifically, +filterUnits+ has((("filterUnits attribute"))) a value of +objectBoundingBox+ by default.((("objectBoundingBox units", "with filterUnits"))) If you wish to specify boundaries in user units, then set the attribute’s value to +userSpaceOnUse+.((("userSpaceOnUse setting", "for filterUnits")))

You can also specify the units used in the filter primitives with the +primitiveUnits+ attribute.((("primitiveUnits attribute, filter element"))) Its default value is +userSpaceOnUse+, but if you set it to +objectBoundingBox+, then you can express units as a percent of the graphic's size.((("objectBoundingBox units", "with primitiveUnits")))((("userSpaceOnUse setting", "for primitiveUnits")))

[[gaussian-blur-section]]

==== Using <feGaussianBlur> for a Drop Shadow

Between the beginning and ending +<filter>+ tags are the filter primitives((("filters", "creating a drop shadow", "using feGaussianBlur"))) that perform the operations you desire. Each primitive has one or more inputs, and exactly one output. An input can be the original graphic, specified as +SourceGraphic+, the alpha (opaqueness) channel of the graphic,((("alpha value", "SourceAlpha filter input"))) specified as +SourceAlpha+, or the output of a previous filtering primitive. The alpha source is useful when you’re interested in only the shape of the graphic, regardless of color; it avoids the interactions of alpha and color, as described in <<clipping-masking-chapter>>, in <<masking-section>>.

<<gaussian-blur-bad-example>> is a first attempt to produce a drop shadow on the flower, using the +<feGaussianBlur>+ filter((("feGaussianBlur filter"))) primitive. We specify +SourceAlpha+ as its input (the +in+ attribute), and the amount of blur with the +stdDeviation+ attribute. The larger this number, the greater the blur. If you give two numbers separated by whitespace as the value for +stdDeviation+, the first number is taken as the blur in the _x_-direction and the second as the blur in the _y_-direction.

[[gaussian-blur-bad-example]]
.First attempt to produce a drop shadow

====
[source,xml]
----
<defs>
  <filter id="drop-shadow">
      <feGaussianBlur in="SourceAlpha" stdDeviation="2"/>
  </filter>
</defs>

<g id="flower" filter="url(#drop-shadow)">
    <!-- drawing here -->
</g>
----
====

<<gaussian-blur-bad-figure>> shows the result, which is probably not what you thought it would be.

Don’t be surprised; remember, the filter returns the output, which is a blurred alpha channel, _instead_ of the original source graphic. You could get the effect you want by putting the flower within the +<defs>+ section of the document and changing the SVG to read as follows:

[source,xml]
----
<use xlink:href="#flower" filter="url(#drop-shadow)"
    transform="translate(4, 4)"/>
<use xlink:href="#flower"/>
----

[[gaussian-blur-bad-figure]]
.Result of first attempt at a drop shadow
image::images/sve2_1102.png[]

However, that would require SVG to execute all the elements that make up the flower twice. Instead, the solution is to add more filter primitives, so that all the work can be handled during rendering.

[[store-chain-merge-filter-section]]

==== Storing, Chaining, and Merging Filter Results

<<gaussian-blur-good-example>> is the updated ((("filters", "creating a drop shadow", "storing, chaining, and merging filter results")))filter.

++++
<example id="gaussian-blur-good-example">
<title>Improved drop shadow filter</title>
<screen language="xml">&lt;filter id="drop-shadow"&gt;
  &lt;feGaussianBlur in="SourceAlpha" stdDeviation="2" <emphasis role="strong">result="blur"</emphasis>&gt;  <co id="idsf1"/>
  &lt;feOffset <emphasis role="strong">in="blur"</emphasis> dx="4" dy="4" <emphasis role="strong">result="offsetBlur"</emphasis>&gt;  <co id="idsf2"/>
  &lt;feMerge&gt;    <co id="idsf3"/>
        &lt;feMergeNode in="offsetBlur"&gt;
        &lt;feMergeNode in="SourceGraphic"/&gt;
  &lt;/feMerge&gt;
&lt;/filter&gt;</screen>
</example>
<calloutlist>
<callout arearefs="idsf1">
<para>
The <literal>result</literal> attribute specifies that the result of this primitive can be referenced later by the name <literal>blur</literal>. This isn’t like an XML <literal>id</literal>; the name you give is a local name that’s valid only for the duration of the primitives contained in the current <literal>&lt;filter&gt;</literal>.
</para>
</callout>
<callout arearefs="idsf2">
<para>
The <literal>&lt;feOffset&gt;</literal> primitive takes its input, in this case the <literal>blur</literal> result from the Gaussian blur, offsets it by the specified <literal>dx</literal> and <literal>dy</literal> values, and stores the resulting bitmap under the name <literal>offsetBlur</literal>.<indexterm>
  <primary>feMergeNode element</primary>
</indexterm>
</para>
</callout>
<callout arearefs="idsf3">
<para>
The <literal>&lt;feMerge&gt;</literal> primitive encloses a list of <literal>&lt;feMergeNode&gt;</literal> elements, each of which specifies an input. The inputs are stacked one on top of another in the order that they appear. In this case, you want the <literal>offsetBlur</literal> below the original <literal>SourceGraphic</literal>.
</para>
</callout>
</calloutlist>
++++

You can now refer to this improved drop shadow filter sequence when drawing the flower, producing a surprisingly pleasant image in <<gaussian-blur-good-figure>>.

[source,xml]
----
<g id="flower" filter="url(#drop-shadow)">
    <!-- drawing here -->
</g>
----

[[gaussian-blur-good-figure]]

.Result of improved drop shadow
image::images/sve2_1103.png[]


[NOTE]
====
When you first start working with filters, we strongly recommend that you do things in stages, testing filters one at a time. I created large numbers of stunningly ugly results during botched attempts to discover how a filter really works. You probably will too. We’ll just keep it as our little secret.

Similarly, when you first learn about filters, you will be tempted to apply as many of them as possible to a drawing, just to see what will happen. Your purpose is experimentation, so go ahead. Once you finish experimenting and begin production work, the purpose of the filter changes. Filters should support and enhance your message, not overwhelm it. Judicious use of one or two filters is a buoy; a flotilla of filters almost always sinks the message.((("drop shadow, creating", range="endofrange", startref="ix_dropshadow")))
====


[[glowing-shadow-section]]

=== Creating a Glowing Shadow

The drop shadow works well on the flower, but looks totally unimpressive when applied((("filters", "creating a glowing shadow")))((("text", "drop shadow applied to"))) to text, as you can see in <<drop-shadow-text-figure>>.

[[drop-shadow-text-figure]]

.Drop shadow applied to text
image::images/sve2_1104.png[]

The text would look better with a glowing turquoise area surrounding it,((("text", "glowing shadow for"))) and you can create this effect with the +<feColorMatrix>+ primitive to change black to a different color.

[[feColorMatrix-section]]

==== The <feColorMatrix> Element

The +<feColorMatrix>+ element allows you to change color values in a very generalized way.((("feColorMatrix filter", id="ix_feColMat", range="startofrange")))((("colors", "changing with feColorMatrix", id="ix_colorsMatrix", range="startofrange"))) The sequence of primitives used to create a glowing turquoise shadow is shown in <<glowing-shadow-example>>.


[[glowing-shadow-example]]
.Glow filter

====
[language="xml"]
[subs="specialcharacters,callouts,quotes"]
----
<filter id="glow">
  <feColorMatrix type="matrix"
    values=
      "0 0 0 0   0
       0 0 0 0.9 0
       0 0 0 0.9 0
       0 0 0 1   0"/>
  <feGaussianBlur stdDeviation="2.5" 
    result="coloredBlur"/> 
  <feMerge>
    <feMergeNode in="coloredBlur"/>
    <feMergeNode in="SourceGraphic"/>
  </feMerge>
</filter>
----
====

The +<feColorMatrix>+ is a very versatile primitive, allowing you to modify any of the color or alpha values of a pixel. When the +type+ attribute equals +matrix+, you must set the +value+ to a series of 20 numbers describing the transformation. The 20 numbers are best understood when written in four rows of five columns each.  Each row represents an algebra equation defining how to calculate the output R, G, B, or A value (in order by row). The numbers in the row are multiplied by the input pixel's value for R, G, B, and A and the constant 1 (in order by column), and then added together to get the output value. To set up a transformation that paints all opaque areas the same color, you can ignore the input colors and the constant, and just set the values in the alpha column.((("alpha value", "changing with feColorMatrix element")))  The model for such a matrix looks like this:

[language="xml"]
[subs="specialcharacters,quotes"]
----
values=
  "0 0 0 _red_ 0
   0 0 0 _green_ 0
   0 0 0 _blue_ 0
   0 0 0 1 0"
---- 

where the red, green, and blue values are decimal numbers that usually range from 0 to 1. In <<glowing-shadow-example>>, red is set to to 0, and the green and blue values are set to 0.9, which will produce a bright cyan color.

You’ll note that the example does not have an +in+ attribute for the input to this primitive; the default is to use the +SourceGraphic+. There is also no +result+ attribute on this primitive. This means that the color matrix operation’s output is available only as the implicit input to the next filter primitive. If you use this shortcut, then the next filter primitive must _not_ have an +in+ attribute.

In the example, the result of +<feColorMatrix>+ is a cyan-colored source. The rest of the filter uses a Gaussian blur to spread it out; the resulting cyan-colored blur is stored for future reference as +coloredBlur+. Finally, +<feMerge>+ produces the output glow underneath the object in question.

With these two filters, you can create the new, improved <<glowing-shadow-figure>> with SVG like this:

[source,xml]
----
<g id="flower" style="filter: url(#drop-shadow);">
  <!-- draw the flower -->
</g>
<text x="120" y="50"
  style="filter: url(#glow); fill: #003333; font-size:18;"">
Spring <tspan x="120" y="70">Flower</tspan>
</text>
----

[[glowing-shadow-figure]]

.Drop shadow and glowing text
image::images/sve2_1105.png[]

[[more-feColorMatrix-section]]

==== More About the <feColorMatrix> Element

The preceding example used the most general kind of color matrix, where you get to specify any values you wish. There are three other values for the +type+ attribute. Each of these “built-in” color matrices accomplishes a particular visual task and has its own way of specifying +values+:

+hueRotate+:: The +values+ is a single number that tells how many degrees the color values should be rotated. The mathematics used to accomplish this are very similar to those used in the +rotate+ transformation as described in <<rotate-transform-section>> in <<transformation-chapter>>. The relation between rotation and resulting color is not at all obvious, [offline_only]#as shown in <<hueRotate-figure>>; you may want to experiment with the online version:#
+
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch11/hue_rotate.html[width="100%", height="700px"]

[[hueRotate-figure]]
.Result of hueRotate on fully saturated colors
[role="offline_only"]
image::images/sve2_1106.png[]

+saturate+:: The +values+ attribute specifies a single number in the range 0 to 1. The smaller the number, the more “washed out” the colors will be, [offline_only]#as you see in <<saturate-figure>>.# [online_only]#as you see in the following interactive example.#  A value of 0 converts the graphic to black and white.  The filter can be used only to de-saturate (wash out) an image; you cannot increase saturation (to make a normal image technicolor) with this method.
+
Test out other saturation values with the online example:
+
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch11/saturate.html[width="100%", height="730px"]

[[saturate-figure]]
.Result of saturate on primary and secondary colors
[role="offline_only"]
image::images/sve2_1107.png[]


+luminanceToAlpha+:: This filter creates an alpha channel based upon a color’s luminance.((("alpha value", "luminanceToAlpha filter preset"))) The luminance is the inherent “brightness” of a color, as described in <<masking-section>> in <<clipping-masking-chapter>>. In <<luminance-to-alpha-figure>>, the luminance of the colored squares is used as an alpha channel for solid black squares.  The filter discards the color of the original squares, with the result being solid black with varying opacity levels. The lighter a color, the less the transparency it confers upon the filtered object. The +values+ attribute is ignored for this +type+.

[[luminance-to-alpha-figure]]

.Result of luminanceToAlpha
image::images/sve2_1108.png[]

[[feImage-section]]

=== The <feImage> Filter

Up to this point, you have seen only the original((("colors", "changing with feColorMatrix", range="endofrange", startref="ix_colorsMatrix")))((("feColorMatrix filter", range="endofrange", startref="ix_feColMat"))) graphic or its alpha channel as input to a filter.((("images", "feImage filter")))((("feImage filter"))) SVG’s +<feImage>+ element lets you use any JPG, PNG, or SVG file—or an SVG element with an +id+ attribute—as input to a filter. <<feImage-example>> imports a picture of the sky with a cloud in it to use as a background for the picture of the flower.

[[feImage-example]]
.Using the feImage element
====
[language="xml"]
[subs="specialcharacters,quotes"]
----
<defs>
<filter id="sky-shadow" filterUnits="objectBoundingBox">
    *<feImage xlink:href="sky.jpg" result="sky"    
         x="0" y="0" width="100%" height="100%"
         preserveAspectRatio="none"/>*
    <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur"/>
    <feOffset in="blur" dx="4" dy="4" result="offsetBlur"/>
    <feMerge>
        *<feMergeNode in="sky"/>*
        <feMergeNode in="offsetBlur"/>
        <feMergeNode in="SourceGraphic"/>
    </feMerge>
</filter>
</defs>

<g id="flower" style="filter: url(#sky-shadow)">
    <!-- flower graphic goes here -->
</g>

<!-- show original image -->
<image xlink:href="sky.jpg" x="170" y="10"
    width="122" height="104"/>
----
====

<<feImage-figure>> shows the result, with the original picture of the sky shown at right at its true size. The image is stretched to fit the filter region defined on the +<filter>+ element by default (there are no dimensions on the filter, so the default filter region is 10% padding around the object bounding box). You can set explicit height, width, and x/y offsets on the +<feImage>+ element. By default, these measurements are in +userSpaceOnUse+ units; however, any percentage values are calculated relative to the filter region. You can use the +primitiveUnits+ attribute on the +<filter>+ element to switch to +objectBoundingBox+ units, but this will affect all the elements in the filter.

[[feImage-figure]]

.Result of feImage
image::images/sve2_1109.png[]

[NOTE]
====
In addition to importing a complete image file, you can use a URL fragment in the +xlink:href+ attribute ((("xlink:href attribute", "feImage element")))to import part of an SVG graphic—from a file or from elsewhere in the same SVG—into your filter.  Unfortunately, image fragments in +<feImage>+ are not yet supported in Mozilla Firefox.  You can monitor https://bugzilla.mozilla.org/show_bug.cgi?id=455986[Bugzilla bug 455986] to see if that changes.
====

[[feComponentTransfer-section]]

=== The <feComponentTransfer> Filter

The problem with the background is that it is too dark.((("feComponentTransfer filter", id="ix_feCompTrans", range="startofrange"))) Using +saturate+ isn’t the answer; it changes the intensity of the color, but maintains its brightness (luminance). To lighten the image, you need to increase the value of each color channel.  You could do this with a custom color matrix, but +<feComponentTransfer>+ provides an easier and more flexible way to manipulate each channel (component) separately.  It also lets you adjust each color channel differently, so you can make the blue sky both lighter _and_ less intense by increasing the level of green and red more than the blue level.

You adjust the levels of red, green, blue, and alpha by ((("feFuncR, feFuncG, feFuncB, and feFuncA elements")))placing a +<feFuncR>+, +<feFuncG>+, +<feFuncB>+, and +<feFuncA>+ element inside +<feComponentTransfer>+. Each of these subelements may independently specify a +type+ attribute telling how that particular channel is to be modified.

To simulate the effect of a brightness control, ((("brightness, changing with feComponentTransfer")))you specify the +linear+ function, which places the current color value +C+ into the formula _++slope++_ +&#x2a; C &#x2b;+ __++intercept++__. The _++intercept++_ provides a “base value” for the result; the +_slope_+ is a simple scaling factor. <<linear-transfer-example>> uses a filter that adds a brightened sky to the flower with the drop shadow. [offline_only]#Note that the red and green channels are adjusted differently than the blue channel. This dramatically brightens the sky in <<linear-transfer-figure>>.# [online_only]#The starting values adjust the red and green channels differently than the blue channel, creating a dramatically brighter sky.#

++++
<?hard-pagebreak?>
++++

[[linear-transfer-example]]
.Changing brightness with feComponentTransfer
====
[role="online_only"]
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch11/linear_transfer.html[width="100%", height="600px"]

[role="offline_only"]
[language="xml"]
[subs="specialcharacters,quotes"]
----
<filter id="brightness-shadow" filterUnits="objectBoundingBox">
  <feImage xlink:href="sky.jpg" result="sky"/>
  *<feComponentTransfer in="sky" result="sky">
    <feFuncB type="linear" slope="3" intercept="0"/>
    <feFuncR type="linear" slope="1.5" intercept="0.2"/>
    <feFuncG type="linear" slope="1.5" intercept="0.2"/>
  </feComponentTransfer>*
  <feGaussianBlur in="SourceAlpha" stdDeviation="2" result="blur"/>
  <feOffset in="blur" dx="4" dy="4" result="offsetBlur"/>
  <feMerge>
    <feMergeNode in="sky"/>
    <feMergeNode in="offsetBlur"/>
    <feMergeNode in="SourceGraphic"/>
  </feMerge>
</filter>
----
=====

[[linear-transfer-figure]]
[role="offline_only"]
.Result of linear component transfer
image::images/sve2_1110.png[]


A simple linear adjustment will add and multiply the same amount to every color value within a channel. This is not the case with the +gamma+ function, which((("feComponentTransfer filter", "gamma adjustment with"))) places the current color value +C+ into the formula 
_++amplitude++_ +&#x2a;+ +C^_exponent_^ &#x2b;+ _++offset++_. The _++offset++_ provides a “base value” for the result; the _++amplitude++_ is a simple scaling factor, and _++exponent++_ makes the result a curved line rather than a straight line. Because the color value is always between 0 and 1, the larger your exponent, the _smaller_ the modified value will be. <<gamma-curves-figure>> shows the curves generated with exponent values of 0.6 (the solid black line), 0.3 (the dashed line), and 1.66667 (the gray line). 

Looking at the dashed line, you can see that a low original color value such as 0.1 will be boosted to 0.5, a 400% increase. An original value of 0.5, on the other hand, will increase only 60% to 0.8.  The effect is to brighten the image as a whole and to increase the contrast in dark areas while reducing contrast in light areas.  For exponents greater than 1 (the gray line), the modified values are smaller than the original, darkening the image while increasing the contrast in bright areas. Note that the solid gray and black lines are symmetrical around the diagonal: the gamma value of 1.6667 is the inverse of a gamma of 0.6.   In any case, the exponent has no effect when the original value is either 0 or 1.

[[gamma-curves-figure]]
.Gamma curve functions
image::images/sve2_1111.png[]

When you specify a gamma filter, you set the +amplitude+, +exponent+, and +offset+ attributes to correspond to the values in the preceding formula. <<gamma-transfer-example>> uses gamma correction to adjust the sky. [offline_only]#In this particular case, the differences between Figures pass:[<xref linkend="linear-transfer-figure" xrefstyle="select: labelnumber"/>] and pass:[<xref linkend="gamma-transfer-figure" xrefstyle="select: labelnumber"/>] are minor,# [online_only]#In these examples, the differences between linear and gamma functions are minor,# but there are some images that can be improved much more by one method than by the other.

[[gamma-transfer-example]]
.Gamma adjustment with feComponentTransfer
====
[role="online_only"]
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch11/gamma_transfer.html[width="100%", height="600px"]

[role="offline_only"]
[source,xml]
----
<feImage xlink:href="sky.jpg" result="sky"/>
<feComponentTransfer in="sky" result="sky">
  <feFuncB type="gamma"
    amplitude="1" exponent="0.2" offset="0"/>
  <feFuncR type="gamma"
    amplitude="1" exponent="0.707" offset="0"/>
  <feFuncG type="gamma"
    amplitude="1" exponent="0.707" offset="0"/>
</feComponentTransfer>
----

====
[[gamma-transfer-figure]]
[role="offline_only"]
.Result of using gamma correction
image::images/sve2_1112.png[]


[NOTE]
====
The astute reader (that’s you) may have observed that both linear and gamma functions can produce color values greater than 1.0. The SVG specification says this is not an error; after each filter primitive, the SVG processor will clamp the values to a valid range. Thus, any value greater than 1.0 is reduced to 1.0, and any value less than 0 is set to 0.
====

+<feComponentTransfer>+ has other options for the +type+ attribute. Note that you may mix and match any of these; you can gamma-correct the red values while brightening the green values with a linear function:

+identity+:: A “do-nothing” function. This lets you explicitly state that a color channel should remain unaffected. (This is the default if you don’t provide an ++<feFunc__X__>++ element for a particular channel.)

+table+:: Lets you divide the color values into a series of equal intervals, each of which will be proportionately scaled. Consider the following remapping, which doubles the value of the lowest quarter of the color range, squeezes the next quarter into a range of one-tenth, keeps the third quarter in exact proportion, and then squeezes the last quarter of the values into the remaining 15% of the color range:
+
[options="header"]
|===============
|Original value range|Modified value range
|0.00–0.25|0.00–0.50
|0.25–0.50|0.50–0.60
|0.50–0.75|0.60–0.85
|0.75–1.00|0.85–1.00
|===============


You would specify this mapping for the green channel by listing the endpoints of the remapped range in the +tableValues+ attribute:

[source,xml]
----
<feFuncG type="table"
  tableValues ="0.0, 0.5, 0.6, 0.85, 1.0"/>
----

If you are dividing the input spectrum into _n_ different sections, you must provide __n__&#x2b;1 items in +tableValues+, separated by whitespace or commas:

+discrete+:: Lets you divide the color values into a series of equal intervals, each of which will be mapped to a single discrete color value. Consider the following remapping, which maps the value of the lowest quarter of the color range to 0.125, sets the next quarter to 0.375, the third quarter to 0.625, and remaining quarter to 0.875 (i.e., each quarter of the range is mapped to its center point):
+
[options="header"]
|===============
|Original value range|Modified value
|0.00–0.25|0.125
|0.25–0.50|0.375
|0.50–0.75|0.625
|0.75–1.00|0.875
|===============

You would specify this mapping for the green channel by listing the discrete values, separated by commas or whitespace, in the +tableValues+ attribute:

[source,xml]
----
<feFuncG type="discrete"
  tableValues ="0.125 0.375 0.625 0.875"/>
----

Dividing the input channel into _n_ sections requires _n_ entries in the +tableValues+ attribute. __Exception__: If you want to remap all the input values to a single output value, you must place that entry into +tableValues+ twice. Thus, to set any input value of the blue channel to 0.5, you would say:

[language="xml"]
----
<feFuncB type="discrete" tableValues="0.5 0.5"/>
----

[NOTE]
====
If you want to invert the range of color values for a channel (i.e., change increasing values from a minimum to maximum into decreasing values from the maximum to the minimum), use this:

[subs="specialcharacters,quotes"]
----
<feFunc__X__ type="table"
  tableValues="_maximum_ _minimum_"/>
----
====

<<discrete-table-transfer-figure>> shows the result of using discrete and table transfers as well as inversion via a table transfer.

[[discrete-table-transfer-figure]]
.Result of using table and discrete transfers
image::images/sve2_1113.png[]


[[color-space-sidebar]]
.Defining the Color Space
****
Ordinarily, the values for red, green, or blue run in a straight line from 0 to 1, with 0 being((("colors", "defining the color space"))) none of the color and 1 being 100% of the color. This is called a __linear color space__.((("linear RGB color space"))) However, when SVG calculates the((("gradients", "color values between gradient stops"))) color values between gradient stops (as described in <<patterns-gradients-chapter>>, in <<gradient-section>>), SVG uses a special way of representing color such that the values do not follow a straight line from 0 to 1. This representation is called the((("standard RGB (sRGB) color space"))) standard RGB or link:$$http://www.w3.org/Graphics/Color/sRGB.html$$[_sRGB_ color space], and its use can make gradients much more natural-looking. <<linear-vs-srgb-figure>> shows a comparison. The first gradient goes from black to green, the second from red to green to blue, and the third from black to white.

By default, filter arithmetic calculates any interpolated (“in-between”) values in the linear RGB space, so if you apply a filter to an object that has been filled with a gradient, you will get results that aren’t at all what you expect. In order to get the correct result, you must tell the filter to do its calculations in sRGB space by adding a +color-interpolation-filters="sRGB"+ attribute to your +<filter>+ element. As pass:[<phrase role="keep-together">an alternative</phrase>], you may choose to leave the filter alone and apply +color-interpolation="linearRGB"+ to the +<gradient>+ element, so that it uses the same color space as the default for filters.

[[linear-vs-srgb-figure]]
.Comparison of linearRGB and sRGB
image::images/sve2_1114.png[]

****

[[feComposite-section]]

=== The <feComposite> Filter

So far we have combined the results of ((("feComponentTransfer filter", range="endofrange", startref="ix_feCompTrans")))filters by using +<feMerge>+ to layer the intermediate results one over another.((("feMerge filter"))) The much more general +<feComposite>+ element((("feComposite filter"))) takes two inputs, specified with the +in+ and +in2+ attributes, and an +operator+ that tells how the two are to be combined. In the following explanation, presume you’ve specified +result="A"+ and +result="B"+ for previous filter primitive outputs:

++<feComposite operator="++**++over++**++"++ +in="A" in2="B"/>+:: Produces the result of layering +A+ over +B+, exactly as +<feMergeNode>+ does. In fact, +<feMergeNode>+ is((("feMergeNode element"))) really just a convenient shortcut for an +<feComposite>+ element that specifies an +over+ operation. (+<feMergeNode>+ also allows you to layer more than two graphics at a time.)

++<feComposite operator="++**++in++**++"++ +in="A" in2="B"/>+:: The result is the parts of +A+ that overlap the opaque areas of +B+. It is similar to a masking effect, but the mask is based on only the alpha channel of ++B++, not its color luminance. Don’t confuse the name of this attribute value with the +in+ attribute. 

++<feComposite operator="++**++out++**++"++ +in="A" in2="B"/>+:: The result is the parts of +A+ that are outside the opaque areas of +B+ (with a reverse-masking effect for partially transparent areas).

++<feComposite operator="++**++atop++**++"++ +in="A" in2="B"/>+:: The result is the part of +A+ that is inside B, as well as the part of +B+ outside A. To quote the article in which these operators were first defined: “...__paper__ atop _table_ includes _paper_ where it is on top of _table_, and _table_ otherwise; area beyond the edge of the table is out of the picture.”footnote:[“Compositing Digital Images,” T. Porter, T. Duff, SIGGRAPH ’84 Conference Proceedings, Association for Computing Machinery, Volume 18, Number 3, July 1984.]

++<feComposite operator="++**++xor++**++"++ +in="A" in2="B"/>+:: The result is the part of +A+ that is outside +B+ together with the part of +B+ that is pass:[<phrase role="keep-together">outside <literal>A</literal></phrase>].

++<feComposite in="A" in2="B" operator="++**++arithmetic++**++"++.../>:: The ultimate in flexibility. You provide four coefficients: +k1+, +k2+, +k3+, and +k4+. The result for each channel of each pixel is calculated as follows:
+
----
k1 * A * B + k2 * A + k3 * B + k4
----
+
where +A+ and +B+ are the values for that channel and pixel from the input graphics.

[NOTE]
====
The arithmetic operator is useful for doing a “dissolve” effect. If you want to have a resulting image that is _a_% of image A and _b_% of image B, set +k1+ and +k4+ to 0, +k2+ to +_a_+/100, and +k3+ to +_b_+/100. For example, to make a blend with 30% of +A+ and 70% of +B+, you’d use this:

[source,xml]
----
<feComposite in="A" in2="B" result="combined"
  k1="0" k2="0.30" k3="0.70" k4="0"/>
----
====

<<feComposite-figure>> shows the combinations we’ve described, with red text as the +in+ image and a blurred offset shadow as the +in2+ image; the arithmetic blend is 50% of the text and 50% of its shadow.

[[feComposite-figure]]

.Result of using feComposite operators
image::images/sve2_1115.png[]

<<feComposite-cutout-example>> uses the +in+ and +out+ operators to do “cut-outs.” The drop shadow has been eliminated from this example to produce a more visually pleasing result in <<feComposite-cutout-figure>>.

[[feComposite-cutout-example]]
.Use of feComposite in and out

====
[source,xml]
----
<defs>
<filter id="sky-in" filterUnits="objectBoundingBox">
  <feImage xlink:href="sky.jpg" result="sky"
    x="0" y="0" width="100%" height="100%"
    preserveAspectRatio="none"/>
  <feComposite in="sky" in2="SourceGraphic"
    operator="in"/>
</filter>

<filter id="sky-out" filterUnits="objectBoundingBox">
  <feImage xlink:href="sky.jpg" result="sky"
    x="0" y="0" width="100%" height="100%"
    preserveAspectRatio="none"/>
  <feComposite in="sky" in2="SourceGraphic"
    operator="out"/>
</filter>

<g id="flower">
  <!-- flower graphic goes here -->
</g>
</defs>

<use xlink:href="#flower" transform="translate(10,10)"
  style="filter: url(#sky-in);"/>

<use xlink:href="#flower" transform="translate(170,10)"
  style="filter: url(#sky-out);"/>
----
====

[[feComposite-cutout-figure]]

.Result of feComposite in and out
image::images/sve2_1116.png[]

[[feBlend-section]]

=== The <feBlend> Filter

But wait, there’s more! Yes, filters provide yet another way to combine images.((("feBlend filter"))) The +<feBlend>+ element requires two inputs, specified with the +in+ and +in2+ attributes, and a +mode+ that tells how the inputs are to be blended. The possible values are: +normal+, +multiply+, +screen+, +lighten+, and +darken+. Given opaque inputs +<feBlend in="A" in2="B" mode="_m_"/>+, the following describes the color of the resulting pixel for each mode:

////
[options="header"]
|===============
|Mode|Effect
| +normal+::B only; this is the same as the +over+ operator in +<feComposite>+.
| +multiply+ | As the name suggests, the resulting color value is the product of +A+’s color value and +B+’s color value. This darkens colors, with the strongest effect for dark colors or very different intense colors, and no effect when one of the colors is white.
| +screen+ | Adds the color values together, then subtracts their product. Bright or light colors tend to dominate over dark colors, but colors of similar brightness get combined.
| +darken+ | Takes the minimum of A and B. This is the darker color, hence the name.
| +lighten+ | Takes the maximum of A and B. This is the lighter color, hence the name.
|===============
////

+normal+::
  ++B++ only; this is the same as the +over+ operator in +<feComposite>+.
+multiply+::
  Multiplies (as the name suggests) ++A++’s value and ++B++’s value for each color channel. Because color values are in the range 0–1, multiplying them makes them _smaller_. This darkens colors, with the strongest effect for dark colors or very different intense colors, and no effect when one of the colors is white. The result is similar to creating photographic slides for both images and then stacking them together in the same slide projector—only the light that passes through both is visible.
+screen+::
  Adds the color values together for each channel, and then subtracts their product. Bright or light colors tend to dominate over dark colors, but colors of similar brightness get combined. The result is similar to having two different slide projectors, one for each image, shining on the same screen—bright light from one projector overpowers shadows from the other.
+darken+::
  Takes the minimum of ++A++ and ++B++ in each channel. This is the darker color, hence the name.
+lighten+::
  Takes the maximum of ++A++ and ++B++ in each channel. This is the lighter color, hence the name.

Note that the appropriate calculation is done independently for each of the red, green, and blue values. So, if you were to darken a pure red square with RGB values of (100%, 0%, 0%) and a gray square with RGB values of (50%, 50%, 50%), the resulting color would be (50%, 0%, 0%). If the inputs are not opaque, then all the modes except for +screen+ factor in the transparencies when making the calculations.

Finally, once the color value is calculated, the opacity of the result is determined by the formula +1 – (1 –+ _++opacity of++_ __++A++__++)++ +&#x2a; (1 –+ _++opacity++_ +of+ __++B++__++)++. Using this formula, two opaque items will still be opaque; two items that are 50% opaque will combine to one that is 75% opaque.

<<feBlend-figure>> shows the result of blending an opaque, white-to-black gradient bar with opaque and 50% opaque color squares that have RGB values of black (+#000+), yellow (+#ff0+), red (+#f00+), medium-bright green (+#0c0+), and dark blue (+#009+).

[[feBlend-figure]]

.Result of feBlend
image::images/sve2_1117.png[]

[[flood-tile-section]]

=== The <feFlood> and <feTile> Filters

The +<feFlood>+ and +<feTile>+ elements((("feFlood and feTile filters"))) are __utility filters__. Much like +<feOffset>+, they allow you to carry out certain common operations within a series of filter primitives rather than having to create extra SVG elements in your main graphic.

+<feFlood>+ provides a solid-colored area for use in compositing or merging. You provide the +flood-color+ and +flood-opacity+, and the filter does the rest.

+<feTile>+ takes its input and tiles it horizontally and vertically to fill the area specified in the filter.((("tiles", "feTile filter"))) The size of the tile itself is specified by the size of the input to +<feTile>+.

<<flood-tile-example>> uses +<feComposite>+ to cut out the flooded and tiled area to the shape of a flower. The image used as a tile is shown for reference at the upper right of <<flood-tile-figure>>.

[[flood-tile-example]]
.Example of feFlood and feTile

====
[source,xml]
----
<defs>
<filter id="flood-filter" x="0" y="0" width="100%" height="100%">
  <feFlood flood-color="#993300" flood-opacity="0.8" result="tint"/>
  <feComposite in="tint" in2="SourceGraphic"
    operator="in"/>
</filter>

<filter id="tile-filter" x="0" y="0" width="100%" height="100%">
  <feImage xlink:href="cloth.jpg" width="32" height="32"
    result="cloth"/>
  <feTile in="cloth" result="cloth"/>
  <feComposite in="cloth" in2="SourceGraphic"
    operator="in"/>
</filter>

<g id="flower">
    <!-- flower graphic goes here -->
</g>
</defs>

<use xlink:href="#flower" transform="translate(0, 0)"
  style="filter: url(#flood-filter);"/>
<use xlink:href="#flower" transform="translate(110,0)"
  style="filter: url(#tile-filter);"/>
<image xlink:href="cloth.jpg" x="220" y="10"
  width="32" height="32"/>
----
====

[[flood-tile-figure]]

.Result of feFlood and feTile elements
image::images/sve2_1118.png[]

[[lighting-effects-section]]

=== Lighting Effects

If you draw a bright green circle with SVG, it looks like a refugee from a traffic signal, glowing by its own light and otherwise lying flat on the screen.((("filters", "lighting effects")))((("lighting effects"))) If you look at a circle cut out of green construction paper, it looks more “real” because it is lit from an outside source and has some texture. A circle cut from green plastic not only is lit from outside; it also has reflected highlights. Light from an outside source is called __diffuse lighting__, and the highlights that reflect off a surface are called __specular lighting__, from the Latin _speculum_, meaning _mirror_.

In order to achieve these effects, you must specify the following:

* The type of lighting you want (+<feDiffuseLighting>+ or +<feSpecularLighting>+)
* The object you want to light
* The color of light you are using
* The type of light source you want (+<fePointLight>+, +<feDistantLight>+, or +<feSpotLight>+) and its location

You specify the location of a light source in three dimensions; this means you will need a _z_-value in addition to _x_- and _y_-values. As with two-dimensional graphics, the positive _x_-axis goes from left to right, and the positive _y_-axis goes from top to bottom. The positive _z_-axis is “coming out of the screen” and pointing at you.

Both these lighting effects use the alpha channel of the object they are illuminating ((("bump map, in lighting filters")))as a _bump map_; higher alpha values are presumed to be “raised” above the surface of the object.

////
[[three-d-axes-figure]]

.Relationship of x-, y,- and z-axes
image::images/web/ch11/svge.1019.png[]
////

[[diffuse-lighting-section]]

==== Diffuse Lighting

The best way to show how the +<feDiffuseLighting>+ element((("feDiffuseLighting filter")))((("diffuse lighting")))((("lighting effects", "diffuse lighting")))((("filters", "lighting effects", "diffuse lighting"))) works is to jump right into <<diffuse-lighting-example>>, which shines a pale yellow light on a green circle, textured with the curve pattern from <<simple-pattern-example>>.

++++
<example id="diffuse-lighting-example">
<title>Diffuse lighting with a point light source</title>
<screen language="xml">&lt;defs&gt;
  &lt;path id="curve" d="M 0 0 Q 5 20 10 10 T 20 20"     <co id="dl01"/>
      style="stroke: black; fill: none;"/&gt;     <co id="dl02"/>

  &lt;filter id="diff-light" color-interpolation-filters="sRGB"
    x="0" y="0" width="100%" height="100%"&gt;    <co id="dl03"/>

    &lt;feImage xlink:href="#curve" result="tile"
        width="20" height="20"/&gt;     <co id="dl04"/>

    &lt;feTile in="tile" result="tile"/&gt;

    <emphasis role="strong">&lt;feDiffuseLighting in="tile"</emphasis>     <co id="dl05"/>
        <emphasis role="strong">lighting-color="#ffffcc"</emphasis>
        <emphasis role="strong">surfaceScale="1"</emphasis>      <co id="dl06"/>
        <emphasis role="strong">diffuseConstant="0.5"</emphasis>      <co id="dl07"/>
        <emphasis role="strong">result="diffuseOutput"&gt;</emphasis>     <co id="dl08"/>
        <emphasis role="strong">&lt;fePointLight x="0" y="50" z="50"/&gt;</emphasis>     <co id="dl09"/>
    <emphasis role="strong">&lt;/feDiffuseLighting&gt;</emphasis>     <co id="dl10"/>

    &lt;feComposite in="diffuseOutput" in2="SourceGraphic"
        operator="in" result="diffuseOutput"/&gt;    <co id="dl11"/>

    &lt;feBlend in="diffuseOutput" in2="SourceGraphic"
        mode="screen"/&gt;     <co id="dl12"/>
  &lt;/filter&gt;
&lt;/defs&gt;

&lt;circle id="green-light" cx="50" cy="50" r="50"
    style="fill: #060; filter: url(#diff-light)"/&gt;     <co id="CO6-13"/></screen>
</example>
<calloutlist>
<callout arearefs="dl01">
<para>
Define the curve to be used as the tile.
</para>
</callout>
<callout arearefs="dl02">
<para>
Set the color interpolation method and the boundaries for the filter.
</para>
</callout>
<callout arearefs="dl03">
<para>
Tile the area of the filter with the <literal>curve</literal> image. This will become the bump map.
</para>
</callout>
<callout arearefs="dl04">
<para>
This tiled area is the input to the <literal>&lt;feDiffuseLighting&gt;</literal> element, which is illuminated with a pale yellow light, as specified by the <literal>lighting-color</literal> attribute.
</para>
</callout>
<callout arearefs="dl05">
<para>
The <literal>surfaceScale</literal> attribute tells the height of the surface for an alpha value of 1. (More generally, it&#8217;s the factor by which the alpha value is multiplied.)
</para>
</callout>
<callout arearefs="dl06">
<para>
<literal>diffuseConstant</literal> is a multiplicative factor that is used in determining the final RGB values of a pixel. It must have a value greater than or equal to 0; its default value is 1. The brighter your <literal>lighting-color</literal>, the smaller this number should be (unless you like having your picture washed out).
</para>
</callout>
<callout arearefs="dl07">
<para>
The result of this filter will be named <literal>diffuseOutput</literal>.
</para>
</callout>
<callout arearefs="dl08">
<para>
This example uses a <emphasis>point light source</emphasis>, which means a source that radiates light in all directions. It is positioned at the left center of the area we wish to illuminate, and it is 50 units in front of the screen. The farther you set the light away from the object, the more evenly the object is illuminated. In this example, the light is up close and personal to get the greatest possible effect.
</para>
</callout>
<callout arearefs="dl09">
<para>
The end of the <literal>&lt;feDiffuseLighting&gt;</literal> element.
</para>
</callout>
<callout arearefs="dl10">
<para>
<literal>&lt;feComposite&gt;</literal>’s <literal>in</literal> operator clips the filter’s output to the boundaries of the source graphic (the circle).
</para>
</callout>
<callout arearefs="dl11">
<para>
Finally, <literal>&lt;feBlend&gt;</literal> in <literal>screen</literal> mode, which tends to lighten the input, creates the final part of the filter.
</para>
</callout>
<callout arearefs="dl12">
<para>
Activate the filter on the desired object to produce <xref linkend="diffuse-lighting-figure"/>.
</para>
</callout>
</calloutlist>
++++

[NOTE]
====
The input to this filter is a four-color graphic, but only the alpha channel is used. However, when I (David) inserted a +<feColorMatrix type="luminanceToAlpha">+ and used its output as the input to the filter, I did not get the desired effect. Remember that +luminanceToAlpha+ converts black areas (zero luminance) to complete transparency (zero alpha).  That leaves no difference in alpha levels between the black squiggle pattern and the transparent empty background, and therefore no texture for the lighting effects.  
====

[[diffuse-lighting-figure]]

.Result of applying diffuse lighting filter
image::images/sve2_1119.png[]

[[specular-lighting-section]]

==== Specular Lighting

Specular lighting, on the other hand, gives highlights((("specular lighting")))((("filters", "lighting effects", "specular lighting")))((("lighting effects", "specular lighting")))((("feSpecularLighting filter"))) rather than illumination. <<specular-lighting-example>> shows how this works.

++++
<example id="specular-lighting-example">
<title>Specular lighting with a distant light</title>
<screen language="xml">&lt;defs&gt;
  &lt;path id="curve" d="M 0 0 Q 5 20 10 10 T 20 20"
   style="stroke: black; fill: none;"/&gt;    <co id="sl01"/>

  &lt;filter id="spec-light" color-interpolation-filters="sRGB"
    x="0" y="0" width="100%" height="100%"&gt;     <co id="sl02"/>

    &lt;feImage xlink:href="#curve" result="tile"
        width="20" height="20"/&gt;     <co id="sl03"/>

    &lt;feTile in="tile" result="tile"/&gt;

    <emphasis>&lt;feSpecularLighting in="tile"</emphasis>     <co id="sl04"/>
        <emphasis>lighting-color="#ffffcc"</emphasis>
        <emphasis>surfaceScale="1"</emphasis>      <co id="sl05"/>
        <emphasis>specularConstant="1"</emphasis>     <co id="sl06"/>
        <emphasis>specularExponent="4"</emphasis>      <co id="sl07"/>
        <emphasis>result="specularOutput"&gt;</emphasis>     <co id="sl08"/>
        <emphasis>&lt;feDistantLight elevation="25" azimuth="0"/&gt;</emphasis>     <co id="sl09"/>
    <emphasis>&lt;/feSpecularLighting&gt;</emphasis>     <co id="sl10"/>

    &lt;feComposite in="specularOutput" in2="SourceGraphic"
        operator="in" result="specularOutput"/&gt;     <co id="sl11"/>

    &lt;feComposite in="specularOutput" in2="SourceGraphic"
        operator="arithmetic" k1="0" k2="1" k3="1" k4="0"/&gt;     <co id="sl12"/>
  &lt;/filter&gt;
&lt;/defs&gt;

&lt;circle id="green-light" cx="50" cy="50" r="50"
  style="fill: #060; filter: url(#spec-light)"/&gt;   <co id="sl13"/></screen>
</example>
<calloutlist>
<callout arearefs="sl01">
<para>
As in the previous example, define the curve.
</para>
</callout>
<callout arearefs="sl02">
<para>
The only difference between this and the previous example is the filter name.
</para>
</callout>
<callout arearefs="sl03">
<para>
As in the previous example, this section tiles the curve.
</para>
</callout>
<callout arearefs="sl04">
<para>
Starts the definition of the <literal>&lt;feSpecularLighting&gt;</literal> filter and specifies the <literal>lighting-color</literal> to be a pale yellow light.
</para>
</callout>
<callout arearefs="sl05">
<para>
The <literal>surfaceScale</literal> attribute tells the height of the surface for an alpha value of 1. (Specifically, it’s the factor by which the alpha value is multiplied.)
</para>
</callout>
<callout arearefs="sl06">
<para>
<literal>specularConstant</literal> is a multiplicative factor used in determining the final RGB values of a pixel. It must have a value greater than or equal to 0; its default value is 1. The brighter your <literal>lighting-color</literal>, the smaller this number should be. The effect of this number is also moderated by the <literal>specularExponent</literal> attribute.
</para>
</callout>
<callout arearefs="sl07">
<para>
<literal>specularExponent</literal> is another factor used in determining the final RGB values of a pixel. This attribute must have a value from 1 to 128; the default value is 1. The larger this number, the more “shiny” the result.
</para>
</callout>
<callout arearefs="sl08">
<para>
The result of this filter will be named <literal>specularOutput</literal>.
</para>
</callout>
<callout arearefs="sl09">
<para>
This example uses a distant light source, one which is so far away from the image that its light hits all parts of the image at the same angle.  Instead of specifying the position of the light source, you specify the angle that the light is coming from.
</para>
<simpara>The <literal>elevation</literal> and <literal>azimuth</literal> attributes let you specify the angle in three dimensions. Specifically, <literal>elevation</literal> gives the angle of light above the plane of the screen: <literal>elevation="0"</literal> is light shining flat across the image, while <literal>elevation="90"</literal> is light shining straight down.</simpara>
<simpara>The <literal>azimuth</literal> specifies the angle within the plane; when <literal>elevation</literal> is 0, <literal>azimuth="0"</literal> specifies light coming from the right of the image (more generally, the positive end of the <emphasis>x</emphasis>-axis); <literal>azimuth="90"</literal> is from the bottom (positive end of the <emphasis>y</emphasis>-axis), <literal>azimuth="180"</literal> is from the left, and <literal>azimuth="270"</literal> is from the top.</simpara>
</callout>
<callout arearefs="sl10">
<para>
The end of the <literal>&lt;feSpecularLighting&gt;</literal> element. Note that the input to this filter was an alpha channel; the output contains both alpha <emphasis>and</emphasis> color information (unlike <literal>&lt;feDiffuseLighting&gt;</literal>, which always produces an opaque result).
</para>
</callout>
<callout arearefs="sl11">
<para>
Use <literal>&lt;feComposite&gt;</literal>’s <literal>in</literal> operator to clip the filter’s output <indexterm>
  <primary>feComposite filter</primary>
</indexterm>to the boundaries of the source graphic (the circle).
</para>
</callout>
<callout arearefs="sl12">
<para>
Finally, use <literal>&lt;feComposite&gt;</literal> with the <literal>arithmetic</literal> operator to do a straight addition of the lighting and the source graphic.
</para>
</callout>
<callout arearefs="sl13">
<para>
Activate the filter on the circle, producing the highlighting relief effect in <xref linkend="specular-lighting-figure"/>.
</para>
</callout>
</calloutlist>
++++

[[specular-lighting-figure]]

.Result of applying specular lighting filter
image::images/sve2_1120.png[]

[NOTE]
====
link:$$http://www.webreference.com/3d/lesson12/$$[An excellent tutorial on lighting effects in three dimensions] is pass:[<phrase role="keep-together">available</phrase>]. We’re working in only two dimensions, but much of the information is applicable.
====

A third type of light source, +<feSpotLight>+, is specified((("spotlight filter")))((("feSpotLight filter"))) with these attributes: +x+, +y+, and +z+, the location of the spotlight (default value is 0); +pointsAtX+, +pointsAtY+, and +pointsAtZ+, the place the spotlight is pointing at (default value is 0); +specularExponent+, a value that controls the focus for the light source (default value is 1); and +limitingConeAngle+, which restricts the region where the light is projected. This is the angle between the spotlight axis and the cone. Thus, if you want a 30-degree spread for the entire cone, specify the angle as 15. (The default value is to allow unlimited spread.)

[[background-filter-section]]

=== Accessing the Background

In addition to the +SourceGraphic+ and +SourceAlpha+ filter inputs, a ((("filters", "accessing the background")))filtered object may access the part of the image that has already been rendered onto the canvas when you invoke a filter. These parts are ((("BackgroundImage filter input")))called +BackgroundImage+ (_not_ +BackgroundGraphic+) and +BackgroundAlpha+.((("BackgroundAlpha filter input"))) In order to access these inputs, the filtered object must be within a container element ((("enable-background attribute")))that has set the +enable-background+ attribute to the value +new+. <<background-image-example>> performs a Gaussian blur on the background image.

++++
<example id="background-image-example">
<title>Accessing the background image</title>
<screen language="xml">&lt;defs&gt;
  &lt;filter id="blur-background"&gt;   <co id="atbi1"/>
    &lt;feGaussianBlur in="BackgroundImage" stdDeviation="2" result="blur" /&gt;
    &lt;feComposite in="blur" in2="SourceGraphic" operator="in" /&gt;
    &lt;feOffset dx="4" dy="4" result="offsetBlur"/&gt;
  &lt;/filter&gt;
&lt;/defs&gt;

&lt;g enable-background="new"&gt;     <co id="atbi2"/>
  &lt;rect x="0" y="0" width="60" height="60"
    style="fill: lightblue; stroke: blue; stroke-width:10" /&gt;    <co id="atbi3"/>
  &lt;circle cx="40" cy="40" r="30"
    style="fill: #fff; filter: url(#blur-background);" /&gt;   <co id="atbi4"/>
&lt;/g&gt;</screen>
</example>
<calloutlist>
<callout arearefs="atbi1">
<para>
This is similar to the blur filter used for drop shadows, except the input is now the <literal>BackgroundImage</literal> rather than the <literal>SourceAlpha</literal>.
</para>
</callout>
<callout arearefs="atbi2">
<para>
Because <literal>&lt;g&gt;</literal> is a container element, it is a perfect candidate for placing the <literal>enable-background</literal>. All the children of this element will have access to the background image and alpha.
</para>
</callout>
<callout arearefs="atbi3">
<para>
The rectangle is drawn onto the canvas <emphasis>and</emphasis> into a background buffer.
</para>
</callout>
<callout arearefs="atbi4">
<para>
The circle does not display directly; the filter blurs the background image (which does not include the circle) and composites <literal>in</literal> the <literal>SourceGraphic</literal>. <xref linkend="background-image-figure"/> shows the result.
</para>
</callout>
</calloutlist>
++++

[WARNING]
====
As of the time of writing, no web browser((("web browsers", "background filter inputs and"))) implements +enable-background+ or the +BackgroundImage+ and +BackgroundAlpha+ inputs.  If you use those inputs in a filter in a browser that does not support them, the filter will not return anything—meaning that the filtered part of your graphic will disappear.

An alternative is to separate out the background into its own +<g>+ element and use +<feImage>+ to import((("feImage filter"))) it into your filter. Adapting <<background-image-example>> in this way results in the following code:

[language="xml"]
[subs="specialcharacters,callouts,quotes"]
----
<defs>
  <filter id="blur-background">   
    <feImage xlink:href="#background" result="bg"/>
    <feGaussianBlur in="bg" stdDeviation="2" result="blur" />
    <feComposite in="blur" in2="SourceGraphic" operator="in" />
    <feOffset dx="4" dy="4" result="offsetBlur"/>
  </filter>
</defs>

<g id="background">
  <rect x="0" y="0" width="60" height="60" 
    style="fill: lightblue; stroke: blue; stroke-width:10" />
</g>
<circle cx="40" cy="40" r="30"
    style="fill: #fff; filter: url(#blur-background);" />
----

The result is the same as <<background-image-figure>> in browsers that support the use of SVG fragments for +<feImage>+ (it currently does not work in Mozilla pass:[<phrase role="keep-together">Firefox)</phrase>].  
====

[[background-image-figure]]
.Result of accessing background image
image::images/sve2_1121.png[]

[[feMorphology-section]]

=== The <feMorphology> Element

The +<feMorphology>+ element lets you “thin” or “thicken” a graphic.((("feMorphology filter"))) You specify an +operator+ with a value of +erode+ to thin or +dilate+ to thicken a graphic. The +radius+ attribute tells us how much the lines are to be thickened or thinned. It’s ordinarily applied to alpha channels. <<feMorphology-example>> erodes and dilates a simple line drawing. [offline_only]#As you see in <<feMorphology-figure>>,# [online_only]#As you can see,# erosion can wreak havoc on a drawing that has thin lines to begin with.

[[feMorphology-example]]
.Thickening and thinning with feMorphology
====
[role="online_only"]
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch11/fe_morphology.html[width="100%", height="500px"]

[role="offline_only"]
[source,xml]
----
<defs>
  <g id="cat" stroke-width="2">
      <!-- drawing of a cat -->
  </g>

  <filter id="erode1">
    <feMorphology operator="erode" radius="1"/>
  </filter>

  <filter id="dilate2">
    <feMorphology operator="dilate" radius="2"/>
  </filter>
</defs>

<use xlink:href="#cat"/>
<text x="75" y="170" style="text-anchor: middle;">Normal</text>

<use xlink:href="#cat" transform="translate(150,0)"
    style="filter: url(#erode1);"/>
<text x="225" y="170" style="text-anchor: middle;">Erode 1</text>

<use xlink:href="#cat" transform="translate(300,0)"
    style="filter: url(#dilate2);"/>
<text x="375" y="170" style="text-anchor: middle;">Dilate 2</text>
----
====

[[feMorphology-figure]]

.Result of using feMorphology
[role="offline_only"]
image::images/sve2_1122.png[]

[[feConvolveMatrix-section]]

=== The <feConvolveMatrix> Element

The +<feConvolveMatrix>+ element lets you calculate((("feConvolveMatrix filter"))) a pixel’s new value in terms of the values of its neighboring pixels. This filter lets you do effects such as blurring, sharpening, embossing, and beveling. It works by combining a pixel with its neighboring pixels to produce a resulting pixel value. Imagine a pixel P and its eight neighboring pixels (the usual case that is used with this filter):

[subs="specialcharacters,quotes"]
----
A  B  C
D  *P*  E
F  G  H
----

You then specify a list of nine numbers in the +kernelMatrix+ attribute. These numbers tell how much to multiply each pixel by. These products will be added up. The sum could well come out to be greater than 1 (if all the factors are positive, for example), so, to even the intensity, the result is divided by the total of the factors. Let’s say you specify these nine numbers (spaced out to show them as a matrix):

[source, xml]
----
<feConvolveMatrix kernelMatrix="
   0  1  2
   3  4  5
   6  7  8"/>
----

The new value of pixel P will then be as follows:

----
P' = ((0*A) + (1*B) + (2*C) +
     (3*D) + (4*P) + (5*E) +
     (6*F) + (7*G) + (8*H)) / ( 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8)
----

The exception is if all your matrix values sum to 0; in this case, no division is performed.

You can also specify a +bias+ property, which shifts the output range of the filter by adding the specified offset value to each pixel. The +bias+ is added after the division, but before the result is clamped to the 0–1 allowable range.

<<emboss-example>> achieves the ((("feConvolveMatrix filter", "embossing effect")))((("embossing effect, using feConvolveMatrix")))embossing effect shown in <<emboss-figure>> by taking the upper-left neighbor minus the lower-right neighbor of each pixel.footnote:[Filters containing +<feConvolveMatrix>+ elements caused rendering errors when tested in Apache Batik version 1.7; the example works as expected when it was tested in web browsers.] The +bias+ of 0.5 is added after the +kernelMatrix+ summation and division is applied.  The bias causes pixels with identical top-left and bottom-right neighbors to be displayed as gray (versus black without a bias shift).  Pixels where the top-left neighbor is brighter than the bottom-left neighbor display in dark colors, while pixels where the bottom-left neighbor is brighter display in bright colors.  As a result, diagonal edges are highlighted as if the image were raised up and lit from the side. The transparent background pixels are considered to have a color of black.

The default behavior of +<feConvolveMatrix>+ is to apply the calculations to all the channels, including alpha.((("alpha value", "feConvolveMatrix filter and")))  With that setting, only the edges of each shape—the ones for which the upper-left neighbors have a higher alpha value than the (transparent background) lower-right neighbors—would be displayed. In order to apply calculations only to the red, green, and blue values, we specified +preserveAlpha+ as +true+; the default value is +false+.

[[emboss-example]]
.Embossing with feConvolveMatrix

====
[source, xml]
----
<defs>
  <filter id="emboss">
    <feConvolveMatrix
      preserveAlpha="true"
      kernelMatrix="1 0 0 0 0 0 0 0 -1"
      bias="0.5"/>
  </filter>

  <g id="flower">
    <!-- flower graphic goes here -->
  </g>
</defs>

<use xlink:href="#flower" style="filter: url(#emboss);"/>
----
====

[[emboss-figure]]

.Result of using feConvolveMatrix
image::images/sve2_1123.png[]


Although the default matrix size is three columns by three rows, you can specify any size you want with the +order+ attribute. If you specify +order="4"+, then the matrix will require sixteen numbers (4 by 4) in the +kernelMatrix+ attribute. A matrix with three columns and two rows would be specified by +order="3 2"+ and would require six numbers. The larger your kernel matrix, the more computation is required to produce the result.

For a pixel in the middle of a graphic, the neighbors are easy to identify. What do you do with the pixels on the edges of the graphic? Who are their neighbors? This decision is made by the setting you give the +edgeMode+ attribute. If you set its value to be +duplicate+ (the default), then +<feConvolveMatrix>+ duplicates the edge values in the required direction to produce a neighbor. The value +wrap+ wraps around to the opposite side to find a neighbor. For example, the neighbor above a pixel at the top is the pixel at the bottom, and the neighbor to the left of a pixel at the left edge is the corresponding pixel at the right edge. This behavior is useful if the image being modified will be used as a repeating tile. The value of +none+ will provide a transparent black pixel (red, green, blue, and alpha values of zero) for any missing neighbors.

[role="online_only"]
Go ahead, experiment with +<feConvolveMatrix>+ and see what you can come up with:

[role="offline_only"]
All the possibilities from +<feConvolveMatrix>+ can't possibly be described here.  Experiment with the online example and see what you can come up with:

iframe::http://oreillymedia.github.io/svg-essentials-examples/ch11/convolve.html[width="100%", height="500px"]


[[feDisplacement-section]]

=== The <feDisplacementMap> Element

This fascinating filter uses the color values of its second input to decide how far to((("feDisplacementMap filter"))) move the pixels in the first input. You specify which color channel should be used to affect the _x_-coordinate of a pixel with the +xChannelSelector+ attribute; the +yChannelSelector+ attribute specifies the color channel used to affect the _y_-coordinate. The legal values for these selectors are +"R"+, +"G"+, +"B"+, and +"A"+ (for the alpha channel). You must specify how far to displace pixels; the +scale+ attribute gives the appropriate scaling factor. If you don’t specify this attribute, the filter won’t do anything.

<<gradient-displacement-example>> creates a gradient rectangle((("gradients", "using as a displacement map"))) as the second input. The displacement factor will be set to 10, the red channel will be used as an _x_ offset, and the green channel will be used as a _y_ offset. <<gradient-displacement-figure>> shows the result of applying this displacement to the flower.

[[gradient-displacement-example]]
.Using a gradient as a displacement map

====
[source,xml]
----
<defs>
  <linearGradient id="gradient">
    <stop offset="0" style="stop-color: #ff0000;" />
    <stop offset="0.5" style="stop-color: #00ff00;"/>
    <stop offset="1" style="stop-color: #000000;"/>
  </linearGradient>

  <rect id="rectangle" x="0" y="0" width="100" height="200"
    style="fill: url(#gradient);"/>

  <filter id="displace">
    <feImage xlink:href="#rectangle" result="grad"/>

    <feDisplacementMap
      scale="10"
      xChannelSelector="R"
      yChannelSelector="G"
      in="SourceGraphic" in2="grad"/>
  </filter>
  <g id="flower">
    <!-- flower graphic goes here -->
  </g>
</defs>

<use xlink:href="#flower" style="filter: url(#displace);"/>
----
====

[[gradient-displacement-figure]]

.Result of using feDisplacementMap
image::images/sve2_1124.png[]

It’s possible to use the same graphic for both inputs. This means a graphic’s displacement is controlled by its own coloration. This effect, as written in <<self-displacement-example>> and displayed in <<self-displacement-figure>>, can be quite eccentric.


[[self-displacement-example]]
.Using a graphic as its own displacement map
====
[source,xml]
----
<defs>
<filter id="self-displace">
  <feDisplacementMap
    scale="10"
    xChannelSelector="R"
    yChannelSelector="G"
    in="SourceGraphic" in2="SourceGraphic"/>
</filter>

<g id="flower">
  <!-- flower graphic goes here -->
</g>
</defs>

<use xlink:href="#flower" style="filter: url(#self-displace);"/>
----
====

[[self-displacement-figure]]

.Same graphic used as both inputs to feDisplacementMap
image::images/sve2_1125.png[]

[[feTurbulence-section]]

=== The <feTurbulence> Element

The +<feTurbulence>+ element lets you produce ((("feTurbulence filter")))artificial textures for effects like marble, clouds, etc. by using equations developed by Ken Perlin.This is referred to as link:$$http://freespace.virgin.net/hugo.elias/models/m_perlin.htm$$[Perlin noise]. You specify these attributes:

+type+:: One of +turbulence+ or +fractalNoise+. Fractal noise is smoother in appearance.

+baseFrequency+:: The larger the number you give as the value for this attribute, the more quickly colors change in the result. This number must be greater than 0 and should be less than 1. You may also give two numbers for this attribute; the first will be the frequency in the _x_ direction, and the second will be the frequency in the _y_ direction.

+numOctaves+:: This is the number of noise functions that should be added together when generating the final result. The larger this number, the more fine-grained the texture. The default value is 1.

+seed+:: The starting value for the random number generator this filter uses. The default value is 0; change it to get some variety in the result.

[role="offline_only"]
<<feTurbulence-figure>> is a screenshot of an SVG file showing various values of the first three of these attributes.

[role="online_only"]
The following interactive allows you to experiment with various values of the first three of these attributes:

[[feTurbulence-figure]]
.Various values of feTurbulence attributes
[role="offline_only"]
image::images/sve2_1126.png[]

[role="offline_only"]
The online example allows you to experiment with all three parameters:

iframe::http://oreillymedia.github.io/svg-essentials-examples/ch11/turbulence.html[width="100%", height="450px"]

[[filter-reference-section]]

=== Filter Reference Summary

The +<filter>+ element contains a series of filter primitives,((("filters", "reference summary"))) each of which takes one or more inputs and provides a single result for use with other filters. The result of the last filter in the series is rendered into the final graphic. You specify the dimensions of the canvas to which the filter applies with the +x+, +y+, +width+, and +height+ attributes. Use +filterUnits+ to specify the units used to define the filter region, and +primitiveUnits+ to specify the coordinate system for the various length values within the filter primitives.

<<filter-reference-table>> presents a filter reference summary.((("elements", "reference tables", "filters"))) Each of the filter primitive elements has an +in+ attribute that gives the source for the primitive, and may also specify an +x+, +y+, +width+, and +height+.

++++
<table id="filter-reference-table">
<title>Filter reference summary</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="22%"/>
<colspec colname="col_2" colwidth="56%"/>
<thead>
<row>
<entry>Element</entry>
<entry>Attributes</entry>
</row>
</thead>
<tbody>
<row>
<entry><simpara><literal>&lt;feBlend&gt;</literal></simpara></entry>
<entry><simpara><literal>in2="</literal><emphasis><literal>second source</literal></emphasis><literal>"</literal></simpara>
<simpara> <literal>mode="normal" | "multiply" | "screen" | "darken" | "lighten"</literal> (default is <literal>normal</literal>)</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feColorMatrix&gt;</literal></simpara></entry>
<entry><simpara><literal>type="matrix" | "saturate" | "hueRotate" |</literal> <literal>"luminanceToAlpha"</literal></simpara>
<simpara> <literal>values="</literal><emphasis><literal>matrix values</literal></emphasis><literal>"</literal> <literal>&#x7c;</literal> <literal>"</literal><emphasis><literal>saturation value (0-1)</literal></emphasis><literal>"</literal> <literal>&#x7c;</literal> <literal>"</literal><emphasis><literal>rotate degrees</literal></emphasis><literal>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feComponentTransfer&gt;</literal></simpara></entry>
<entry><simpara>Container for <literal>&lt;feFuncR&gt;</literal>, <literal>&lt;feFuncG&gt;</literal>, <literal>&lt;feFuncB&gt;</literal>, and <literal>&lt;feFuncA&gt;</literal> elements</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feFunc</literal><emphasis><literal>X</literal></emphasis><literal>&gt;</literal></simpara></entry>
<entry><simpara><literal>type="identity" | "table" | "discrete" | "linear" | "gamma"</literal></simpara>
<simpara> <literal>tableValues="</literal><emphasis><literal>intervals for table, steps for discrete</literal></emphasis><literal>"</literal></simpara>
<simpara> <literal>slope="</literal><emphasis><literal>linear slope</literal></emphasis><literal>"</literal></simpara>
<simpara> <literal>intercept="</literal><emphasis><literal>linear intercept</literal></emphasis><literal>"</literal></simpara>
<simpara> <literal>amplitude="</literal><emphasis><literal>gamma amplitude</literal></emphasis><literal>"</literal></simpara>
<simpara> <literal>exponent="</literal><emphasis><literal>gamma exponent</literal></emphasis><literal>"</literal></simpara>
<simpara> <literal>offset="</literal><emphasis><literal>gamma offset</literal></emphasis><literal>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feComposite&gt;</literal></simpara></entry>
<entry><simpara><literal>in2="</literal><emphasis><literal>second source</literal></emphasis><literal>"</literal></simpara>
<simpara> <literal>operator="over" | "in" | "out" | "atop" | "xor" |</literal> <literal>"arithmetic"</literal></simpara></entry>
</row>
<row>
<entry><simpara></simpara></entry>
<entry><simpara>The following attributes are used with <literal>arithmetic</literal> (any attributes that are not specified have a default value of 0):</simpara>
<simpara> <literal>k1="</literal><emphasis><literal>factor for in1*in2</literal></emphasis><literal>"</literal></simpara>
<simpara> <literal>k2="<replaceable>factor for in1</replaceable>"</literal></simpara>
<simpara> <literal>k3="<replaceable>factor for in2</replaceable>"</literal></simpara>
<simpara> <literal>k4="<replaceable>additive offset</replaceable>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feConvolveMatrix&gt;</literal></simpara></entry>
<entry><simpara><literal>order="<replaceable>columns rows</replaceable>"</literal> (default 3 by 3)</simpara>
<simpara> <literal>kernel="<replaceable>values</replaceable>"</literal></simpara>
<simpara> <literal>bias="<replaceable>offset value</replaceable>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feDiffuseLighting&gt;</literal></simpara></entry>
<entry><simpara>Container for a light source element</simpara>
<simpara> <literal>surfaceScale="<replaceable>height</replaceable>"</literal> (default 1)</simpara>
<simpara> <literal>diffuseConstant="<replaceable>factor</replaceable>"</literal> (must be non-negative; default 1)</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feDisplacementMap&gt;</literal></simpara></entry>
<entry><simpara><literal>scale="<replaceable>displacement factor</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>xChannelSelector="R" | "G" | "B" | "A"</literal></simpara>
<simpara> <literal>yChannelSelector="R" | "G" | "B" | "A"</literal></simpara>
<simpara> <literal>in2="<replaceable>second input</replaceable>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feFlood&gt;</literal></simpara></entry>
<entry><simpara><literal>flood-color="<replaceable>color specification</replaceable>"</literal></simpara>
<simpara> <literal>flood-opacity="<replaceable>value (0-1)</replaceable>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feGaussianBlur&gt;</literal></simpara></entry>
<entry><simpara><literal>stdDeviation="<replaceable>blur spread</replaceable>"</literal> (larger is blurrier; default 0)</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feImage&gt;</literal></simpara></entry>
<entry><simpara><literal>xlink:href="<replaceable>image source</replaceable>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feMerge&gt;</literal></simpara></entry>
<entry><simpara>Container for <literal>&lt;feMergeNode&gt;</literal> elements</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feMergeNode&gt;</literal></simpara></entry>
<entry><simpara><literal>in="<replaceable>intermediate result</replaceable>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feMorphology&gt;</literal></simpara></entry>
<entry><simpara><literal>operator="erode" | "dilate"</literal></simpara>
<simpara> <literal>radius="<replaceable>x-radius y-radius</replaceable>"</literal></simpara>
<simpara> <literal>radius="<replaceable>radius</replaceable>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feOffset&gt;</literal></simpara></entry>
<entry><simpara><literal>dx="<replaceable>x offset</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>dy="<replaceable>y offset</replaceable>"</literal> (default 0)</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feSpecularLighting&gt;</literal></simpara></entry>
<entry><simpara>Container for a light source element</simpara>
<simpara> <literal>surfaceScale="<replaceable>height</replaceable>"</literal> (default 1)</simpara>
<simpara> <literal>specularConstant="<replaceable>factor</replaceable>"</literal> (must be non-negative; default 1)</simpara>
<simpara> <literal>specularExponent="<replaceable>exponent</replaceable>"</literal> (range 1-128; default 1)</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feTile&gt;</literal></simpara></entry>
<entry><simpara>Tiles the <emphasis><literal>in</literal></emphasis> layer</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feTurbulence&gt;</literal></simpara></entry>
<entry><simpara><literal>type="turbulence" | "fractalNoise"</literal></simpara>
<simpara> <literal>baseFrequency="<replaceable>x-frequency y-frequency</replaceable>"</literal></simpara>
<simpara> <literal>baseFrequency="<replaceable>frequency</replaceable>"</literal></simpara>
<simpara> <literal>numOctaves="<replaceable>integer</replaceable>"</literal></simpara>
<simpara> <literal>seed="<replaceable>number</replaceable>"</literal></simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feDistantLight&gt;</literal></simpara></entry>
<entry><simpara><literal>azimuth="<replaceable>degrees</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>elevation="<replaceable>degrees</replaceable>"</literal> (default 0)</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;fePointLight&gt;</literal></simpara></entry>
<entry><simpara><literal>x="<replaceable>coordinate</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>y="<replaceable>coordinate</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>z="<replaceable>coordinate</replaceable>"</literal> (default 0)</simpara></entry>
</row>
<row>
<entry><simpara><literal>&lt;feSpotLight&gt;</literal></simpara></entry>
<entry><simpara><literal>x="<replaceable>coordinate</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>y="<replaceable>coordinate</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>z="<replaceable>coordinate</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>pointsAtX="<replaceable>coordinate</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>pointsAtY="<replaceable>coordinate</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>pointsAtZ="<replaceable>coordinate</replaceable>"</literal> (default 0)</simpara>
<simpara> <literal>specularConstant="<replaceable>focus control</replaceable>"</literal> (default 1)</simpara>
<simpara> <literal>limitingConeAngle="<replaceable>degrees</replaceable>"</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
++++
((("filters", range="endofrange", startref="ix_filters")))