[[xml-appendix]]

[appendix]
== The XML You Need for SVG

The purpose of this appendix is to introduce you to XML.((("XML", id="ix_XML", range="startofrange"))) A knowledge of XML is essential if you wish to write SVG documents directly rather than having them generated by some graphics utility.

If you’re already acquainted with XML, you don’t need to read this appendix. If not, read on. The general overview of XML given in this appendix should be more than sufficient to enable you to work with the SVG documents that you will create. For further information about XML, the O’Reilly books pass:[<emphasis><ulink url="http://bit.ly/Learning_XML_2e" role="orm:hideurl">Learning XML</ulink></emphasis>] by Erik T. Ray and pass:[<emphasis><ulink url="http://bit.ly/XML_ina_Nutshell_3e" role="orm:hideurl">XML in a Nutshell</ulink></emphasis>] by Elliotte Rusty Harold and W. Scott Means are invaluable guides.

Note that this appendix makes frequent reference to the formal XML 1.0 specification, which can be used for further investigation of topics that fall outside the scope of SVG. Readers are also directed to Tim Bray's link:$$http://www.xml.com/axml/testaxml.htm$$[“Annotated XML Specification”], which provides an illuminating explanation of the XML 1.0 specification, and Norm Walsh’s link:$$http://www.xml.com/pub/a/98/10/guide0.html$$[technical introduction to XML].

You may have noticed that these are not recent publications. Don’t be surprised; XML is a solid, long-established standard.

[[what-is-xml-section]]

=== What Is XML?

XML, the Extensible Markup Language, is an Internet-friendly format for((("XML", "defined"))) data and documents, invented by the World Wide Web Consortium (W3C). The _Markup_ denotes a way of expressing the structure of a document within the document itself. XML has its roots in a markup language called SGML (Standard Generalized Markup Language), which is used in publishing and shares this heritage with HTML. XML was created to do for machine-readable documents on the Web what HTML did for human-readable documents—that is, provide a commonly agreed-upon syntax so that processing the underlying format becomes a commodity and documents are made accessible to pass:[<phrase role="keep-together">all users</phrase>].

Unlike HTML, though, XML comes with very little predefined. HTML developers are accustomed both to the notion of using angle brackets < > for denoting elements (i.e., _syntax)_, and also to the set of element names themselves (i.e., head, body, etc.). XML shares only the former feature, the notion of using angle brackets for denoting elements. Unlike HTML, XML has no predefined elements, but is merely a set of rules that lets you write other languages like HTML.footnote:[To clarify XML’s relationship with SGML: XML is an _SGML subset_. By contrast, HTML is an _SGML application_. SVG uses XML to express its operations and thus is an _XML application_.] Because XML defines so little, it is easy for everyone to agree to use the XML syntax, and then to build applications on top of it. It’s like agreeing to use a particular alphabet and set of punctuation symbols, but not saying which language to use. However, if you’re coming to XML from an HTML background, then prepare yourself for the shock of having to choose what to call your tags!

Knowing that XML’s roots lie with SGML should help you understand some of XML’s features and design decisions. Note that, although SGML is essentially a document-centric technology, XML’s functionality also extends to data-centric applications, including SVG. Commonly, data-centric applications do not need all the flexibility and expressiveness that XML provides and limit themselves to employing only a subset of XML’s functionality.

[[xml-document-anatomy-section]]

=== Anatomy of an XML Document

The best way to explain how an XML document is((("XML", "document structure"))) composed is to present one. The following example shows an XML document you might use to describe authors:

[source,xml]
----
<?xml version="1.0" encoding="us-ascii"?>
<authors>
    <person id="lear">
        <name>Edward Lear</name>
        <nationality>British</nationality>
    </person>
    <person id="asimov">
        <name>Isaac Asimov</name>
        <nationality>American</nationality>
    </person>
    <person id="mysteryperson"/>
</authors>
----

The first line of the document is known as the _XML declaration_.((("XML", "XML declaration"))) This tells a processing application which version of XML you are using (the version indicator is mandatory) and which character encoding you have used for the document. In the previous example, the document is encoded in ASCII. (The significance of character encoding is covered later in this chapter.) If the XML declaration is omitted, a processor will make certain assumptions about your document. In particular, it will expect it to be encoded in UTF-8, an encoding of the Unicode character set. However, it is best to use the XML declaration wherever possible, both to avoid confusion over the character encoding and to indicate to processors which version of XML you’re using.

[[xml-elements-attributes-section]]

==== Elements and Attributes

The second line of the example begins((("elements", "XML"))) an _element_, which has been named _authors_. The contents((("XML", "elements and attributes"))) of that element include everything between the right angle bracket (+>+) in +<authors>+ and the left angle bracket (+<+) in +</authors>+. The actual syntactic constructs +<authors>+ and +</authors>+ are often referred to as the element _start tag_ and _end tag_, respectively. Do not confuse tags with elements! Note that elements may include other elements, as well as text. An XML document must contain exactly one _root element_, which contains all other content within the document. The name of the root element defines the type of the XML document.

Elements that contain both text and other elements simultaneously are classified as _mixed content_. The SVG +<text>+ element is such an element; it can contain text and +<tspan>+ elements.

The sample _authors_ document uses elements named +person+ to describe the authors themselves. Each person element has an _attribute_ named +id+.((("attributes", "in XML markup"))) Unlike elements, attributes can contain only textual content. Their values must be surrounded by quotes. Either single quotes (+'+) or double quotes (+"+) may be used, as long as you use the same kind of closing quote as the opening one.

Within XML documents, attributes are frequently used for _metadata_ (i.e., data about data)—describing properties of the element’s contents.((("metadata"))) This is the case in our example, where +id+ contains a unique identifier for the person being described.

As far as XML is concerned, it does not matter in what order attributes are presented in the element start tag. For example, these two elements contain exactly the same information as far as an XML 1.0 conformant processing application is concerned:

[source,xml]
----
<animal name="dog" legs="4"/>
<animal legs="4" name="dog"/>
----

On the other hand, the information presented to an application by an XML processor on reading the following two lines will be different for each animal element because the ordering of elements is significant:

[source,xml]
----
<animal><name>dog</name><legs>4</legs></animal>
<animal><legs>4</legs><name>dog</name></animal>
----

XML treats a set of attributes like a bunch of stuff in a bag—there is no implicit ordering—while elements are treated like items on a list, where ordering matters.

New XML developers frequently ask when it is best to use attributes to represent information and when it is best to use elements. As you can see from the authors example, if order is important to you, then elements are a good choice. In general, there is no hard-and-fast “best practice” for choosing whether to use attributes or elements.

The final author described in our document has no information available. All we know about this person is his or her ID, +mysteryperson+. The document uses the XML shortcut syntax for an empty element. The following is a reasonable alternative:

[source,xml]
----
<person id="mysteryperson"></person>
----

[[xml-name-syntax-section]]

==== Name Syntax

XML 1.0 has certain rules about element and attribute names.((("XML", "name syntax"))) In particular:

* Names are case-sensitive: e.g., +<person/>+ is not the same as +<Person/>+.
* Names beginning with _xml_ (in any permutation of uppercase or lowercase) are reserved for use by XML 1.0 and its companion specifications.
* A name must start with a letter or an underscore, not a digit, and may continue with any letter, digit, underscore, or period.footnote:[Actually, a name may also contain a colon, but the colon is used to delimit a _namespace prefix_ and is not available for arbitrary use. For more information, see http://www.xml.com/pub/a/1999/01/namespaces.html[Tim Bray’s “XML Namespaces by Example.”]]

A precise description of names can be found in link:$$http://www.w3.org/TR/REC-xml/#sec-common-syn$$[section 2.3 of the XML 1.0 specification]. The rules for names in XML 1.1 are slightly different, primarily with regard to Unicode characters. SVG uses the XML 1.0 rules.

[[well-formed-xml-section]]

==== Well-Formed

An XML document that conforms to the rules of XML syntax is known as _well-formed_. ((("well-formed XML")))((("XML", "well-formed")))At its most basic level, well-formedness means that elements should be properly matched, and all opened elements should be closed. A formal definition of well-formedness can be found in link:$$http://www.w3.org/TR/REC-xml/#sec-well-formed$$[section 2.1 of the XML 1.0 specification]. <<poorly-formed-xml-table>> shows some XML documents that are not well-formed.

++++
<?hard-pagebreak?>
++++

++++
<table id="poorly-formed-xml-table">
<title>Examples of poorly formed XML documents</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33%"/>
<colspec colname="col_2" colwidth="61%"/>
<thead>
<row>
<entry>Document</entry>
<entry>Reason why it’s not well-formed</entry>
</row>
</thead>
<tbody>
<row>
<entry><programlisting language="xml">&lt;foo&gt;
  &lt;bar&gt;
  &lt;/foo&gt;
&lt;/bar&gt;</programlisting></entry>
<entry><simpara>The elements are not properly nested because <literal>foo</literal> is closed while inside its child <phrase role='keep-together'>element bar</phrase>.</simpara></entry>
</row>
<row>
<entry><programlisting language="xml">&lt;foo&gt;
  &lt;bar&gt;
&lt;/foo&gt;</programlisting></entry>
<entry><simpara>The <literal>bar</literal> element was not closed before its parent, <literal>foo</literal>, was closed.</simpara></entry>
</row>
<row>
<entry><programlisting language="xml">&lt;foo baz&gt;
&lt;/foo&gt;</programlisting></entry>
<entry><simpara>The <literal>baz</literal> attribute has no value. While this is permissible in HTML (e.g., <literal>&lt;table                 border&gt;</literal>), it is forbidden in XML.</simpara></entry>
</row>
<row>
<entry><programlisting language="xml">&lt;foo baz=23&gt;
&lt;/foo&gt;</programlisting></entry>
<entry><simpara>The <literal>baz</literal> attribute value, <literal>23</literal>, has no surrounding quotes. Unlike HTML, all attribute values must be quoted in XML.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
++++


[[xml-comment-section]]

==== Comments

As in HTML, it is possible to include _comments_ within XML documents. XML comments are ((("comments", "in XML")))((("XML", "comments")))intended to be read only by people. With HTML, developers have occasionally employed comments to add application-specific functionality. For example, the server-side include functionality of most web servers uses instructions embedded in HTML comments. XML provides other means of indicating application-processing instructions,footnote:[A discussion of _processing instructions (PIs)_ is outside the scope of this book. For more information on PIs, see section 2.6 of the XML 1.0 specification, at link:$$http://www.w3.org/TR/REC-xml#sec-pi$$[].] so comments should not be used for any purpose other than those for which they were intended.

The start of a comment is indicated with +<!--+, and the end of the comment with +-\->+. Any sequence of characters, aside from the string +--+, may appear within a comment.

Comments tend to be used more in XML documents intended for human consumption than those intended for machine consumption. The +<desc>+ and +<title>+ elements in SVG obviate much of the need for comments.

[[xml-entity-section]]

==== Entity References

Another feature of XML that is occasionally useful when writing SVG((("XML", "entity references"))) documents is the mechanism for _escaping_ characters.((("escaping characters")))

Because some characters have special significance in XML, there needs to be a way to represent them. For example, in some cases the +<+ symbol might really be intended to mean _less than_ rather than to signal the start of an element name. Clearly, just inserting the character without any escaping mechanism would result in a poorly formed document because a processing application would assume you were starting another element. Another instance of this problem is needing to include both double quotes and single quotes simultaneously in an attribute’s value. Here’s an example that illustrates both these difficulties:

[source,xml]
----
<badDoc>
  <para>
    I'd really like to use the < character
  </para>
  <note title="On the proper 'use' of the " character"/>
</badDoc>
----

XML avoids this problem by the use of the _predefined entity reference_.((("entity references (XML)"))) The word _entity_ in the context of XML simply means a unit of content. The term _entity reference_ means just that, a symbolic way of referring to a certain unit of content. XML predefines entities for the following symbols: left angle bracket (+<+), right angle bracket (+>+), apostrophe (+'+), double quote (+"+), and ampersand (+&+).

An entity reference is introduced with an ampersand (+&+), which is followed by a name (using the word _name_ in its formal sense, as defined by the XML 1.0 specification), and terminated with a semicolon (+;+). <<xml-predefined-entity-table>> shows how the five predefined entities can be used within an XML document.

[[xml-predefined-entity-table]]
.Predefined entity references in XML 1.0
[options="header"]
|===============
|Literal character|Entity reference
|+<+|+\&lt;+
|+>+|+\&gt;+
|+'+|+\&apos;+
|+"+|+\&quot;+
|+&+|+\&amp;+

|===============


Here’s the problematic document revised to use entity references:

[source,xml]
----
<badDoc>
  <para>
    I'd really like to use the &lt; character
  </para>
  <note title="On the proper &apos;use&apos; 
                of the &quot; character"/>
</badDoc>
----

Being able to use the predefined entities is all you need for SVG; in general, entities are provided as a convenience for human-created XML. XML 1.0 allows you to define your own entities and use entity references as “shortcuts” in your document. link:$$http://www.w3.org/TR/REC-xml/#sec-physical-struct$$[Section 4 of the XML 1.0 specification] describes the use of entities.

[[xml-character-references-section]]

==== Character References

You are likely to find _character references_ in the context of SVG documents.((("character references")))((("XML", "character references")))((("Unicode", "code points"))) Character references allow you to denote a character by its numeric position in the Unicode character set (this position is known as its _code point_). <<xml-utf8-character-table>> contains((("code point, in character encodings"))) a few examples that illustrate the syntax.

[[xml-utf8-character-table]]
.Example character references in UTF-8
[options="header"]
|===============
|Actual character|Character reference
|+1+|+&amp;#49;+
|+A+|+&amp;#65;+
|+Ñ+|+&amp;#xD1;+
|+®+|+&amp;#xAE;+
|===============


Note that the code point can be expressed in decimal or, with the use of _x_ as a prefix, in hexadecimal.

[[xml-character-encodings-section]]

=== Character Encodings

The subject of character encodings is frequently a mysterious one for developers.((("XML", "character encodings")))((("character encodings"))) Most code tends to be written for one computing platform and, normally, to run within one organization. Although the Internet is changing things quickly, most of us have never had cause to think too deeply about internationalization.

XML, designed to be an Internet-friendly syntax for information exchange, has internationalization at its very core. One of the basic requirements for XML processors is that they support the Unicode standard character encoding. Unicode attempts to include the requirements of all the world’s languages within one character set. Consequently, it is very large!

[[xml-unicode-encoding-section]]

==== Unicode Encoding Schemes

Unicode 3.0 has over 57,700 code points, each of((("Unicode", "encoding schemes"))) which corresponds to a character.footnote:[You can obtain charts of all these characters online by visiting link:$$http://www.unicode.org/charts/$$[].] If one were to express a Unicode string by using the position of each character in the character set as its encoding (in the same way as ASCII does), expressing the whole range of characters would require four octetsfootnote:[An _octet_ is a string of 8 binary digits, or bits. A _byte_ is commonly, but not always, considered the same thing as an octet.] for each character. Clearly, if a document is written in 100 percent American English, it will be four times larger than required—all the characters in ASCII fitting into a 7-bit representation. This places a strain both on storage space and on memory requirements for processing applications.

Fortunately, two encoding schemes for Unicode alleviate this problem: _UTF-8_ and _UTF-16_. As you might guess from their names, applications can process documents in these encodings in 8- or 16-bit segments at a time. When code points are required in a document that cannot be represented by one chunk, a bit pattern is used that indicates that the following chunk is required to calculate the desired code point. In UTF-8, this is denoted by the most significant bit of the first octet being set to 1.

This scheme means that UTF-8 is a highly efficient encoding for representing languages using Latin alphabets, such as English. All of the ASCII character set is represented natively in UTF-8—an ASCII-only document and its equivalent in UTF-8 are byte-for-byte identical.

This knowledge will also help you debug encoding errors. One frequent error arises because of the fact that ASCII is a proper subset of UTF-8—programmers get used to this fact and produce UTF-8 documents, but use them as if they were ASCII. Things start to go awry when the XML parser processes a document containing, for example, characters such as _Á_. Because this character cannot be represented using only one octet in UTF-8, this produces a two-octet sequence in the output document; in a non-Unicode viewer or text editor, it looks like a couple of characters of garbage.

[[xml-other-encodings-section]]

==== Other Character Encodings

Unicode, in the context of computing history, is a relatively new invention.((("character encodings", "other than Unicode"))) Native operating system support for Unicode is by no means universal. For instance, older systems like Windows 95 and 98 do not have it.

XML 1.0 allows a document to be encoded in any character set registered with the Internet Assigned Numbers Authority (IANA). European documents are commonly encoded in one of the _ISO Latin_ character sets, such as ISO-8859-1. Japanese documents commonly use _Shift-JIS_, and Chinese documents use _GB2312_ and _Big 5_.

A full list of registered character sets is maintained by the pass:[<ulink url="http://www.iana.org/assignments/character-sets/character-sets.xhtml">Internet Assigned <phrase role="keep-together">Numbers Authority (IANA)</phrase></ulink>].

XML processors are not required by the XML 1.0 specification to support any more than UTF-8 and UTF-16, but most commonly support other encodings, such as US-ASCII and ISO-8859-1. Although most SVG transactions are currently conducted in ASCII (or the ASCII subset of UTF-8), there is nothing to stop SVG documents from containing, say, Korean text. You will, however, probably have to dig into the encoding support of your computing platform to find out if it is possible for you to use alternative encodings.

[[xml-validity-section]]

=== Validity

In addition to well-formedness, XML 1.0 offers another level of verification, called _validity_. ((("validity (XML)")))((("XML", "validity")))To explain why validity is important, let’s take a simple example. Imagine you invented a simple XML format for your friends’ telephone numbers:

[source,xml]
----
<phonebook>
  <person>
    <name>Albert Smith</name>
    <number>123-456-7890</number>
  </person>
  <person>
    <name>Bertrand Jones</name>
    <number>456-123-9876</number>
  </person>
</phonebook>
----

Based on your format, you also construct a program to display and search your phone numbers. This program turns out to be so useful, you share it with your friends. However, your friends aren’t so hot on detail as you are, and try to feed your program this phone book file with a +<phone>+ element instead of a +<number>+ element:

[source,xml]
----
<phonebook>
  <person>
    <name>Melanie Green</name>
    <phone>123-456-7893</phone>
  </person>
</phonebook>
----

Note that, although this file is perfectly well-formed, it doesn’t fit the format you prescribed for the phone book, and you find you need to change your program to cope with this situation. If your friends had used +number+ as you did to denote the phone number, and not +phone+, there wouldn’t have been a problem. However, as it is, this second file is not a valid phone book document.

For validity to be a useful general concept, you need a machine-readable way of saying what a valid document is; that is, which elements and attributes must be present and in what order. XML 1.0 achieves this by introducing _document type definitions_ (DTDs). For the purposes of SVG, you don’t need to know much about DTDs. Rest assured that SVG does have a DTD, and it spells out in detail exactly which combinations of elements and attributes make up a valid document.

[[xml-dtd-section]]

==== Document Type Definitions (DTDs)

The purpose of a DTD is to express the allowed elements and attributes in a certain document type and to constrain the order in which they must appear within that document type.((("Document Type Definitions (DTD)")))((("DTD (Document Type Definitions)")))((("XML", "Document Type Definitions (DTDs)"))) A DTD contains declarations defining the element types and attribute lists. A DTD may span more than one file, and the SVG 1.1 specification uses a modularized DTD spread over more than a dozen files. However, the mechanism for including one file inside another—parameter entities—is outside the scope of this book. It is common to mistakenly conflate element and element types. The distinction is that an element is the actual instance of the structure as found in an XML document, whereas the element type is the kind of element that the instance is.

[[xml-link-dtd-section]]

==== Putting It Together

What _is_ important to you is knowing how to link a document to its defining DTD. This is done with a document type declaration +<!DOCTYPE+ ...+>+, inserted at the beginning of the XML document,((("XML", "linking a document to its DTD"))) after the XML declaration in our fictitious example:


[source,xml]
----
<?xml version="1.0" encoding="us-ascii"?>
<!DOCTYPE authors SYSTEM "http://example.com/authors.dtd">
<authors>
  <person id="lear">
    <name>Edward Lear</name>
    <nationality>British</nationality>
  </person>
  <person id="asimov">
    <name>Isaac Asimov</name>
    <nationality>American</nationality>
  </person>
  <person id="mysteryperson"/>
</authors>
----

This example assumes the DTD file has been placed on a web server at _example.com_. Note that the document type declaration specifies the root element of the document, not the DTD itself. You could use the same DTD to define _person_, _name_, or _nationality_ as the root element of a valid document. Certain DTDs, such as the DocBook DTD for technical documentation,footnote:[See link:$$http://www.docbook.org$$[].] use this feature to good effect, allowing you to provide the same DTD for multiple document types.

A validating XML processor is obliged to check the input document against its DTD. If it does not validate, the document is rejected. To return to the phone book example, if your application validated its input files against a phone book DTD, you would have been spared the problems of debugging your program and correcting your friend’s XML because your application would have rejected the document as being invalid. Some of the programs that read SVG files have a validating XML processor built into them to assure they have valid input (and to keep you honest!). The kinds of XML processors that are available are discussed in <<xml-tool-section>>.

[[xml-namespaces-section]]

=== XML Namespaces

XML 1.0 lets developers create their own elements and attributes, ((("namespaces")))((("XML", "namespaces")))but this leaves open the potential for overlapping names. +<title>+ may mean the name of a book in one context, but it may mean the prefix for a person’s name (Ms., Dr., etc.) in a different context. link:$$http://www.w3.org/TR/REC-xml-names/$$[The Namespaces in XML specification] provides a mechanism developers can use to identify particular vocabularies using Uniform Resource Identifiers (URIs).

SVG uses the URI link:$$http://www.w3.org/2000/svg$$[] for its namespace. The URI is just an identifier—opening that page in a web browser reveals some links to the SVG, XML 1.0, and Namespaces in XML specifications. Programs processing documents with multiple vocabularies can use the namespaces to figure out which vocabulary they are handling at any given point in a document.

SVG applies the namespace in the root element of SVG documents:

[source,xml]
----
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
....
</svg>
----

The +xmlns+ attribute, which defines the namespace,((("xmlns attribute"))) is actually provided as a default value by the SVG DTD. However, some browsers will not render an SVG document if you don’t use the namespace explicitly. (If the namespace does appear, it must have the exact value shown earlier.) The namespace declaration applies to all of the elements contained by the element in which the declaration appears, including the containing element. This means that the element named _svg_ is in the namespace +http://www.w3.org/2000/svg+.

SVG uses the “default namespace” for its content, using the SVG element names without any prefix. Namespaces can also be applied using prefixes, as shown here:

[source,xml]
----
<svgns:svg xmlns:svgns="http://www.w3.org/2000/svg"
    width="100" height="100">
....
</svgns:svg>
----

In this case, the namespace URI +http://www.w3.org/2000/svg+ would apply to all elements using a prefix of _svgns_. The SVG 1.0 DTD won’t validate against such documents.

Namespaces are very simple on the surface but are a well-known field of combat in XML arcana. For more information on namespaces, see _XML in a Nutshell_ or _Learning XML_ (both O'Reilly).

[[xml-tool-section]]

=== Tools for Processing XML

Many parsers exist for using XML with many different programming languages. Most are freely available, the majority being open source.

[[xml-parser-section]]

==== Selecting a Parser

An XML parser typically((("XML", "parsers")))((("parsers (XML)"))) takes the form of a library of code that you interface with your own program. The SVG program hands the XML over to the parser, and it hands back information about the contents of the XML document. Typically, parsers do this either via events or via a Document Object Model (DOM).((("DOM (Document Object Model)", "DOM-based XML parsers")))

With event-based parsing, the parser calls a function in your program whenever a parse event is encountered. Parse events include things like finding the start of an element, the end of an element, or a comment. Most Java event-based parsers follow link:$$http://www.megginson.com/downloads/SAX/$$[a standard API called SAX], which is also implemented for other languages such as Python and Perl. 

DOM-based parsers work in a markedly different way. They consume the entire XML input document and hand back a tree-like data structure that the SVG software can interrogate and alter. The DOM is a W3C standard link:$$http://www.w3.org/DOM/$$[with its own documentation].

As XML matures, hybrid techniques that give the best of both worlds are emerging. If you’re interested in finding out what’s available and what’s new for your favorite programming language, keep an eye on the following online sources:

_XML.com Resource Guide_::  link:$$http://www.xml.com/resourceguide/$$[]

_Free XML Tools Guide_::  link:$$http://www.garshol.priv.no/download/xmltools/$$[]

[[xml-xslt-section]]

==== XSLT Processors

Many XML applications involve transforming one XML document into another XML document or into HTML. The W3C has defined a special language called _XSLT_ for doing transformations.((("XSLT (Extensible Stylesheet Language Transformations)", "processors"))) XSLT processors are becoming available for all major programming platforms.

XSLT works by using a _stylesheet_, which contains templates that describe how to transform elements from an XML document. These templates typically specify what XML to output in response to a particular element or attribute. Using a W3C technology called _XPath_ gives you the flexibility to say not only “do this for every _person_ element,” but to give instructions as complex as “do this for the third _person_ element whose _name_ attribute is _Fred_.”

Because of this flexibility, some applications have sprung up for XSLT that aren’t really transformation applications at all, but take advantage of the ability to trigger actions on certain element patterns and sequencers. Combined with XSLT’s ability to execute custom code via extension functions, the XPath((("XPath"))) language has enabled applications such as document indexing to be driven by an XSLT processor. You can see a brief introduction to XSLT in <<generating-svg-chapter>>.

The W3C specifications for XSLT and XPath can be found at link:$$http://w3.org/TR/xslt$$[] and link:$$http://w3.org/TR/xpath$$[], respectively.((("XML", range="endofrange", startref="ix_XML")))

