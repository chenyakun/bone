[[paths-chapter]]

== Paths

All of the basic shapes described in <<basic-shapes-chapter>> are really shorthand forms for((("paths", id="ix_paths07", range="startofrange"))) the more general +<path>+ element.((("path element"))) You are well advised to use these shortcuts; they help make your SVG more readable and more structured. The +<path>+ element is more general; it draws the outline of any arbitrary shape by specifying a series of connected lines, arcs, and curves. This outline can be filled and drawn with a stroke, just as the basic shapes are. Additionally, these paths (as well as the shorthand basic shapes) may be used to define the outline of a clipping area or a transparency mask, as you will see in <<clipping-masking-chapter>>.

All of the data describing an outline is in the +<path>+ element’s +d+ attribute (the +d+ stands for _data_).((("d (data) attribute, path element"))) The path data consists of one-letter commands, such as +M+ for _moveto_ or +L+ for _lineto_, followed by the coordinate information for that particular command.

[[moveto-lineto-closepath-section]]

=== moveto, lineto, and closepath

Every path must begin with a _moveto_ command.((("paths", "moveto command")))

The command letter is a capital +M+ followed((("moveto command"))) by an _x-_ and __y-__coordinate, separated by commas or whitespace. This command sets the current location of the “pen” that’s drawing the outline.

This is followed by one or more _lineto_ commands, denoted((("lineto command")))((("paths", "lineto command"))) by a capital +L+, also followed by _x-_ and _y-_ coordinates, and separated by commas or whitespace. <<moveto-lineto-example>> has three paths. The first draws a single line, the second draws a right angle, and the third draws two 30-degree angles. When you “pick up” the pen with another _moveto_, you are starting a new subpath. Notice that you can use either a comma or whitespace to separate the _x_- and __y__-coordinates, as shown in all three paths. [offline_only]#The result is <<moveto-lineto-figure>>.#

++++
<?hard-pagebreak?>
++++

[[moveto-lineto-example]]
.Using moveto and lineto
====
[role="online_only"]
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch07/moveto-lineto.html[width="100%", height="400px"]

[role="offline_only"]
[source,xml]
----
<svg width="150px" height="150px" viewBox="0 0 150 150"
  xmlns="http://www.w3.org/2000/svg">
<g style="stroke: black; fill: none;">
  <!-- single line -->
  <path d="M 10 10 L 100 10"/>

  <!-- a right angle -->
  <path d="M 10, 20  L 100, 20  L  100,50"/>

  <!-- two 30-degree angles -->
  <path d="M 40 60 L 10, 60 L 40 42.68
    M 60, 60 L 90 60 L 60, 42.68"/>
</g>
</svg>
----
====

[[moveto-lineto-figure]]
[role="offline_only"]
.Result of using moveto and lineto
image::images/sve2_0701.png[]

Examining the last path more closely, with commas replaced by whitespace:

[options="header"]
[widthoptions="header"]
[cols="1,2"]
|===============
|Value|Action
| +M 40 60+ |Move pen to (40,60)
| +L 10 60+ |Draw a line to (10,60)
| +L 40 42.68+ |Draw a line to (40,42.68)
| +M 60 60+ |Start a new subpath; move pen to (60,60)—no line is drawn
| +L 90 60+ |Draw a line to (90,60)
| +L 60 42.68+ |Draw a line to (60,42.68)

|===============

[NOTE]
====
You may have noticed the path data doesn’t look very much like the typical values for XML attributes. Because the entire path data is contained in one attribute rather than an individual element for each point or line segment, a path takes up less memory when read into a Document Object Model structure by an XML parser. Additionally, a path’s compact notation allows a complex graphic to be transmitted without requiring a great deal of bandwidth.
====

If you want to use a +<path>+ to draw a rectangle, you can draw all four lines, or you can draw the first three lines and then use the _closepath_ command, ((("Z command (closepath)")))((("closepath command", id="ix_closepath", range="startofrange")))((("paths", "closepath command")))denoted by a capital +Z+, to draw a straight line back to the beginning point of the current subpath. <<closepath-example>> is the SVG for <<closepath-figure>>, which shows a rectangle drawn the hard way, a rectangle drawn with _closepath_, and a path that draws two triangles by opening and closing two subpaths.

[[closepath-example]]
.Using closepath

====
[source,xml]
----
<g style="stroke: black; fill: none;"> 
  <!-- rectangle; all four lines -->
  <path d="M 10, 10 L 40, 10 L 40, 30 L 10, 30 L 10, 10"/>

  <!-- rectangle with closepath -->
  <path d="M 60 10 L 90 10 L 90 30 L 60 30 Z"/> 

  <!-- two 30-degree triangles -->
  <path d="M 40 60 L 10 60 L 40 42.68 Z 
     M 60 60 L 90 60 L 60 42.68 Z"/>
</g>
----

====
Examining the last path more closely:

[options="header"]
[cols="1,2"]
|===============
|Value|Action
| +M 40 60+ |Move pen to (40,50)
| +L 10 60+ |Draw a line to (10,60)
| +L 40 42.68+ |Draw a line to (40,42.68)
| +Z+ |Close path by drawing a straight line to (40,60), where this subpath began
| +M 60 60+ |Start a new subpath; move pen to (60,60)—no line is drawn
| +L 90 60+ |Draw a line to (90,60)
| +L 60 42.68+ |Draw a line to (60,42.68)
| +Z+ |Close path by drawing a straight line to (60,60), where this subpath began

|===============

[[closepath-figure]]

.Result of using closepath
image::images/sve2_0702.png[]

There is another difference between drawing the rectangle with all four lines and using a _closepath_ command.  When you close the path, the start and end lines are joined together to form a continuous shape for stroking styles.((("stroke style", "path closure and"))) The difference is noticeable if you are using wide strokes or +stroke-linecap+ and +stroke-linejoin+ effects.  <<closepath-differ-example>> uses a larger stroke width, and <<closepath-differ-figure>> shows the result, magnified to make the difference more clearly visible.

[[closepath-differ-example]]
.Individual lines versus closepath

====
[source,xml]
----
<g style="stroke: gray; stroke-width: 8; fill: none;">

    <!-- rectangle; all four lines -->
    <path d="M 10 10 L 40 10 L 40 30 L 10 30 L 10 10"/>

    <!-- rectangle with closepath -->
    <path d="M 60 10 L 90 10 L 90 30 L 60 30 Z"/>
</g>
----
====

[[closepath-differ-figure]]

.Result of individual strokes versus closepath
image::images/sve2_0703.png[]

[[relative-moveto-lineto-section]]

=== Relative moveto and lineto

The preceding commands are all represented by uppercase letters, and the coordinates are presumed to be _absolute_ coordinates.((("closepath command", range="endofrange", startref="ix_closepath")))((("paths", "relative moveto and lineto")))((("coordinates", "absolute or relative, moveto and lineto commands")))((("absolute versus relative path notation")))((("relative coordinates, in path commands")))((("moveto command", "relative coordinates")))((("lineto command", "relative coordinates"))) If you use a lowercase command letter,((("L or l command (lineto)", see="lineto command"))) the coordinates are interpreted as being _relative_ to the current pen position. Thus, the following two paths are equivalent:

[source,xml]
----
<path d="M 10 10 L 20 10 L 20 30  M 40 40 L 55 35"
    style="stroke: black;"/>
<path d="M 10 10 l 10  0 l  0 20  m 20 10 l 15 -5"
    style="stroke: black;"/>
----

If you start a path with a lowercase +m+ (_moveto_), ((("M or m command (moveto)")))its coordinates will be interpreted as an absolute position, as there’s no previous pen position from which to calculate a relative position. All the other commands in this chapter also have the same upper- and pass:[<phrase role='keep-together'>lower</phrase>]case distinction. An uppercase command’s coordinates are absolute, and a lowercase command’s coordinates are relative. The _closepath_ command, which has no coordinates, has the same effect in both upper- and lowercase.((("closepath command")))

[[path-shortcuts-section1]]

=== Path Shortcuts

If content is king and design is queen, then bandwidth efficiency is the((("paths", "shortcuts"))) royal courtier who keeps the palace running smoothly. Because any nontrivial drawing will have paths with many tens of coordinate pairs, the +<path>+ element has shortcuts that allow you to represent a path in as few bytes as possible.

[[lineto-section]]

==== The Horizontal lineto and Vertical lineto Commands

Horizontal and vertical lines are common enough to warrant shortcut commands.((("paths", "shortcuts", "horizontal and vertical lineto commands")))((("horizontal lineto command")))((("vertical lineto command")))((("lineto command", "horizontal and vertical lineto commands"))) A path may specify a horizontal line with an +H+ command ((("H or h command (horizontal lines)")))followed by an absolute pass:[<phrase role="keep-together"><emphasis>x</emphasis>-coordinate</phrase>], or an +h+ command followed by a relative _x_-coordinate. Similarly, a vertical line is specified with a +V+ command followed by an absolute _y_-coordinate, or a +v+ command followed((("V or v command (vertical lines)"))) by a relative _y_-coordinate.

The following table compares the short and long way to draw horizontal and vertical lines:

[options="header"]
[cols="1,3,6"]
|===============
|Shortcut|Equivalent to|Effect
| +H 20+ | +L 20 _current_y_+ |Draws a line to absolute location (20,+_current_y_+)
| +h 20+ | +l 20 0+ |Draws a line to (+_current_x_+ + 20,+_current_y_+)
| +V 20+ | +L _current_x_ 20+ |Draws a line to absolute location (+_current_x_+,20)
| +v 20+ | +l 0 20+ |Draws a line to location (+_current_x_+, +_current_y_+ + 20)
|===============


Thus, the following path draws a rectangle 15 units in width and 25 units in height, with the upper-left corner at coordinates (12,24).

[source,xml]
----
<path d="M 12 24 h 15 v 25 h -15 z"/>
----

[[path-shortcuts-section2]]

==== Notational Shortcuts for a Path

Paths can also be made shorter by applying the((("notational shortcuts (paths)")))((("paths", "shortcuts", "notational shortcuts"))) following two rules:

* You may place multiple sets of coordinates after an +L+ or +l+, just as you do in the +<polyline>+ element.((("lineto command", "multiple pairs of coordinates after")))((("polyline element"))) The following six paths all draw the same diamond shown in <<path-shortcuts-figure>>; the first three are in absolute coordinates and the last three in relative coordinates. The third and sixth paths have an interesting twist—if you place multiple pairs of coordinates ((("moveto command", "multiple pairs of coordinates after")))after a _moveto_, all the pairs after the first are presumed to be preceded by a _lineto_:
footnote:[You can also put multiple single coordinates after a _horizontal lineto_ or _vertical lineto_, although you'll only notice an effect if you're using line markers, which we haven't discussed yet. +H 25 35 45+ is the same as +H 45+, and +v 11 13 15+ is the same as +v 39+.]
+
[source,xml]
----
<g style="fill:none; stroke: black">
  <path d="M 30 30 L 55 5 L 80 30 L 55 55 Z"/>
  <path d="M 30 30 L 55 5 80 30 55 55 Z"/>
  <path d="M 30 30 55 5 80 30 55 55 Z"/>
  <path d="m 30 30 l 25 -25 l 25 25 l -25 25 z"/>
  <path d="m 30 30 l 25 -25 25 25 -25 25 z"/>
  <path d="m 30 30 25 -25 25 25 -25 25 z"/>
</g>
----

[[path-shortcuts-figure]]
.Result of drawing a diamond with a path
image::images/sve2_0704.png[]

* Any unnecessary whitespace may be eliminated.((("whitespace", "in path commands"))) You don’t need a blank after a command letter because all commands are one letter only. You don’t need a blank between a number and a command because the command letter can’t be part of the number. You don’t need a blank between a positive and a negative number because the leading minus sign of the negative number can’t be a part of the positive number. This lets you reduce the third and sixth paths in the preceding listing even further:
+
[source,xml]
----
<path d="M30 30 55 5 80 30 55 55Z"/>
<path d="m30 30 25-25 25 25-25 25z"/>
----
+
Another example of the whitespace elimination rule in action is shown by the example that drew a rectangle 15 units in width and 25 units in height, with the upper-left corner at coordinates (12,24):
+
[source,xml]
----
<path d="M 12 24 h 15 v 25 h -15 z"/> <!-- original -->
<path d="M12 24h15v25h-15z"/> <!-- shorter -->
----

[[arc-section]]

=== Elliptical Arc

Lines are simple; two points on a path uniquely determine the line segment between them. Because an infinite number of curves can be drawn between two points, you must give additional information to draw a curved path between them.((("elliptical", see="arcs")))((("arcs", id="ix_elliptarcs", range="startofrange")))((("paths", "elliptical arcs"))) The simplest of the curves we will examine is the elliptical arc—that is, drawing a section of an ellipse that connects two points.

Although arcs are visually the simplest curves, specifying a unique arc requires the _most_ information. The first pieces of information you need to specify are the _x_- and _y_-radii of the ellipse on which the points lie. This narrows it down to two possible ellipses, as you can see in section (a) of <<arc-figure>>. The two points divide the two ellipses into four arcs. Two of them, (b) and (c), are arcs that measure less than 180 degrees. The other two, (d) and (e), are greater than 180 degrees. If you look at (b) and (c), you will notice they are differentiated by their direction; (b) is drawn in the direction of increasing negative (counterclockwise) angle, and (c) in the direction of increasing positive (clockwise) angle. The same relationship holds true between (d) and (e).

But wait—that still doesn’t uniquely specify the potential arcs! There’s no law that says the ellipse has to have its _x_-radius parallel to the _x_-axis. Part (f) of <<arc-figure>> shows the two points with their candidate ellipses rotated 30 degrees with respect to the _x_-axis.

[[arc-figure]]

.Variations of the elliptical arc command
image::images/sve2_0705.png[]

(<<arc-figure>> is adapted from the one found in section 8.3.8 of the World Wide Web Consortium’s SVG specification.)

Thus, an arc command begins with the +A+ abbreviation for absolute coordinates or +a+ for ((("A or a command (elliptical arcs)")))relative coordinates, and is followed by seven parameters:


* The _x_- and _y_-radius of the ellipse on which the points lie.

* The _++x-axis-rotation++_ of the ellipse.

* The _++large-arc-flag++_, which is 0 if the arc’s measure is less than 180 degrees, or 1 if the arc’s measure is greater than or equal to 180 degrees.

* The _++sweep-flag++_, which is 0 if the arc is to be drawn in the negative angle direction, or 1 if the arc is to be drawn in the positive angle direction.

* The ending _x_- and _y_- coordinates of the ending point. (The starting point is determined by the last point drawn or the last _moveto_ command.)

Here are the paths((("arcs", "path syntax"))) used to draw the elliptical arcs in sections (b) through (e) of <<arc-figure>>:

[source,xml]
----
<path d="M 125,75 A100,50 0 0,0 225,125"/> <!-- b -->
<path d="M 125,75 A100,50 0 0,1 225,125"/> <!-- c -->
<path d="M 125,75 A100,50 0 1,0 225,125"/> <!-- d -->
<path d="M 125,75 A100,50 0 1,1 225,125"/> <!-- e -->
----

[role="online_only"]
You can experiment with the arc parameters and see what they do.

[role="offline_only"]
Online, you can experiment with all the arc parameters to see what they do:

[role="online_only"]
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch07/arc.html[width="100%", height="500px"]

As a further example, let’s enhance the background we started in <<image-element-example>> to complete the yin-yang symbol that is part of the Korean flag. <<arc-path-example>> keeps the full ellipses as +<ellipse>+ elements, but creates the semicircles it needs with paths. The result is shown in <<arc-path-figure>>.

[[arc-path-example]]
.Using elliptical arc

====
[source,xml]
----
<svg width="400px" height="300px" viewBox="0 0 400 300"
  xmlns="http://www.w3.org/2000/svg">
  <!-- gray drop shadow -->
  <ellipse cx="154" cy="154" rx="150" ry="120" style="fill: #999999;"/>

  <!-- light blue ellipse -->
  <ellipse cx="152" cy="152" rx="150" ry="120" style="fill: #cceeff;"/>

  <!-- large light red semicircle fills upper half,
      followed by small light red semicircle that dips into
      lower-left half of symbol -->
  <path d="M 302 152 A 150 120, 0, 1, 0, 2 152
      A 75 60, 0, 1, 0, 152 152" style="fill: #ffcccc;"/>

  <!-- light blue semicircle rises into upper-right half of symbol -->
  <path d="M 152 152 A 75 60, 0, 1, 1, 302 152" style="fill: #cceeff;"/>
</svg>
----
====

[[arc-path-figure]]

.Result of using elliptical arc
image::images/sve2_0706.png[]

[WARNING]
====
You cannot draw a full ellipse with a single path command; if the starting and ending points of the arc are the same, there are infinite ways to position the ellipse. SVG viewers will skip such an arc command. If you specify an ellipse that is too small to reach between the starting and ending points, the SVG viewer will scale up the ellipse until it is just big enough. 

For exact details on how out-of-range parameters are handled, see the link:$$http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes$$[specification's arc implementation notes].
====

[[arc-conversion-section]]

=== Converting from Other Arc Formats

You may be wondering why you can’t specify an arc((("arcs", "converting to different formats")))((("paths", "converting from other arc formats"))) by defining a center point for the ellipse, its _x_- and _y_-radius, the starting angle, and the extent of the angle’s arc, as some other vector graphics systems do. This is a straightforward method of specification, and is excellent for drawing arcs as single objects. This, paradoxically, is exactly why SVG instead chooses such a seemingly eccentric method to specify arcs. In SVG, an arc is not presumed to be living in lonely splendor; it is intended to be part of a connected path of lines and curves. (For example, a rounded rectangle is precisely that—a series of lines and elliptical arcs.) Thus, it makes sense to specify an arc by its endpoints.

Sometimes, though, you do want an isolated semicircle (or, more accurately, semi-ellipse). Presume you have an ellipse specified as follows:

[subs="specialcharacters,quotes"]
----
<ellipse cx="_cx_" cy="_cy_" rx="_rx_" ry="_ry_"/>
----

Here are the paths to draw the four possible semi-ellipses (items in parentheses are intended as algebraic expressions to be calculated):

[subs="specialcharacters,quotes"]
----
<!-- northern hemisphere -->
<path d="M _(cx - rx)_ _cy_
  A _rx_ _ry_ 0 1 1 _(cx + rx)_ _cy_"/>
<!-- southern hemipshere -->
<path d="M _(cx - rx)_ _cy_
  A _rx_ _ry_ 0 1 0 _(cx + rx)_ _cy_"/>
<!-- eastern hemisphere -->
<path d="M _cx_ _(cy - ry)_
  A _rx_ _ry_ 0 1 1 _cx_ _(cy + ry)_"/>
<!-- western hemisphere -->
<path d="M _cx_ _(cy - ry)_
  A _rx_ _ry_ 0 1 0 _cx_ _(cy + ry)_"/>
----

Sometimes you may want to draw an arbitrary arc that has been specified in _center-and-angles_ notation and wish to convert it to SVG’s _endpoint-and-sweep_ format. In other cases, you may want to convert an arc from the SVG format to a center-and-angles format. The mathematics for this second case is rather complex, and is detailed in the SVG specification. You can see a JavaScript version of these conversions in <<arc-conversion-appendix>>.


[[bezier-curve-section]]

=== Bézier Curves

Arcs can be characterized as clean and functional, but one would rarely use the word _graceful_ to describe them.((("arcs", range="endofrange", startref="ix_elliptarcs")))((("paths", "Bézier curves", id="ix_pathsBezier", range="startofrange")))((("Bézier curves", id="ix_Bezier", range="startofrange"))) If you want graceful, you need to use curves that are produced by graphing quadratic and cubic equations. Mathematicians have known about these curves for literally hundreds of years, but drawing them was always a computationally demanding task. This changed when Pierre Bézier, an engineer who worked for French car manufacturer Rénault, and Paul de Casteljau, a physicist and mathematician who worked for Citroën, developed and promoted a computationally convenient way to generate these curves.

If you have used graphics programs((("graphics programs, drawing Bézier curves"))) like Adobe Illustrator, you draw these Bézier curves by specifying two points and then moving a “handle” as shown in the following diagram. The end of this handle is called the _control point_, because it controls the shape of the curve. As you move the handle, the curve changes in a way that, to the uninitiated, is completely mystifying. Mike Woodburn, a graphic designer at Key Point Software, suggests <<generic-bezier-figure>> as a way to visualize how the control point and the curve interact: imagine the line is made of flexible metal. Inside the control point is a magnet; the closer a point is to the control point, the more strongly it is attracted.

[[generic-bezier-figure]]

.How graphics programs draw Bézier curves
image::images/sve2_0707.png[]

Another way to visualize the role of the control point is based on the de Casteljau method of constructing the curves. We will use this approach in the following sections. See link:$$http://graphics.cs.ucdavis.edu/~joy/ecs178/Unit-2-Notes/Divide-and-Conquer-Bezier-Curve.pdf$$[further details on the underlying mathematics], presented in a remarkably lucid fashion.

[[quadratic-bezier-section]]

==== Quadratic Bézier Curves

The simplest of the Bézier curves is the quadratic curve.((("quadratic Bézier curves"))) You specify a beginning point, an ending point, and a control point. Imagine two tent poles placed at the endpoints of the line. These tent poles meet at the control point. Stretched between the centers of the tent poles is a rubber band. The place where the curve bends is tied to the exact center of that rubber band. This situation is shown in <<quadratic-bezier-figure>>.

[[quadratic-bezier-figure]]

.Visualizing a quadratic Bézier curve
image::images/sve2_0708.png[]

The lines between the start and endpoints and the control point are tangent to the start and end of the curve.  The curve starts by following the line to the control point, but then bends over to reach the midpoint heading in the same direction as the “tent pole” line. The curve ends by sliding up alongside the line from the control point to the endpoint.
Programs like Adobe Illustrator show you only one of the “tent poles.” The next time you’re using such a program, mentally add in the second pole and the resulting curves will be far less mysterious.

That’s the concept; now for the practical matter of actually producing such a curve in SVG. You specify a quadratic curve in a +<path>+ data with the +Q+ or +q+ command.((("Q or q command (quadratic Bézier curves)"))) The command is followed by two sets of coordinates that specify a control point and an endpoint. The uppercase command implies absolute coordinates; lowercase implies relative coordinates. The curve in <<quadratic-bezier-figure>> was drawn from (30,75) to (300,120) with the control point at (240,30), and was specified in SVG as follows:

++++
<programlisting role="offline_only">&lt;path d="M30 75 Q240 30, 300 120" style="stroke: black; fill: none;"/&gt;</programlisting>
++++

[role="offline_only"]
The online example shows it with and without the “tent poles":

[role="online_only"]
You can modify the curve by dragging the control point.

[role="online_only"]
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch07/quadratic-bezier.html[width="100%", height="400px"]

You may specify several sets of coordinates after a quadratic curve command. This will generate a poly-Bézier curve.((("poly-Bézier curve"))) Presume you want a +<path>+ that draws a curve from (30,100) to (100,100) with a control point at (80,30) and then continues with a curve to (200,80) with a control point at (130,65). Here is the SVG for this path, with control point coordinates in bold. The result is shown in the left half of <<multi-quadratic-bezier-figure>>; the control points and lines are shown in the right half of the figure:

++++
<screen>&lt;path d="M30 100 Q <emphasis role="strong">80 30</emphasis>, 100 100, <emphasis role="strong">130 65</emphasis>, 200 80"/&gt;</screen>
++++

[[multi-quadratic-bezier-figure]]

.Quadratic poly-Bézier curve
image::images/sve2_0709.png[]

You are probably wondering, “What happened to _graceful_? That curve is just lumpy.” This is an accurate assessment. Just because curves are connected doesn’t mean they will look good together.  That’s why SVG provides the _smooth quadratic curve_ command,((("smooth quadratic curve command")))((("T or t command (smooth quadratic curves)"))) which is denoted by the letter +T+ (or +t+ if you want to use relative coordinates). The command is followed by the next endpoint of the curve; the control point is calculated automatically, as the specification says, by “reflection of the control point on the previous command relative to the current point.”


[NOTE]
====
For the mathematically inclined, the new control point _++x2++_, _++y2++_ is calculated from the previous segment’s endpoint _++x++_, _++y++_ and the previous control point _++x1++_, _++y1++_ with these formulas:
----
x2 = x + (x - x1) = 2 * x - x1
y2 = y + (y - y1) = 2 * y - y1
----
====

Here is a quadratic Bézier curve drawn from (30,100) to (100,100) with a control point at (80,30) and then smoothly continued to (200,80). [offline_only]#The left half of <<smooth-quadratic-figure>> shows the curve; the right half shows the control points. The reflected control point is shown with a dashed line.# Gracefulness has returned!

----
<path d="M30 100 Q 80 30, 100 100 T 200 80"/>
----

[[smooth-quadratic-figure]]
.Smooth quadratic poly-Bézier curve
[role="offline_only"]
image::images/sve2_0710.png[]

[role="offline_only"]
The online example allows you to experiment with the quadratic poly-Bézier curve:

[role="online_only"]
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch07/smooth-quadratic-bezier.html[width="100%", height="350px"]

[[cubic-bezier-section]]

==== Cubic Bézier Curves


A single quadratic Bézier curve has exactly one peak or valley per curve segment.((("cubic Bézier curves"))) While these curves are more versatile than simple arcs, you can do even better by using cubic Bézier curves, which can have both a peak and a valley in the same segment, among other possible shapes.  In other words, a cubic curve can contain an inflection point (the point where the curve changes from bending in one direction to bending in the other).

The difference between the quadratic and cubic curves is that the cubic curve has two control points, one for each endpoint. The technique for generating the cubic curve is similar to that for generating the quadratic curve. [offline_only]#As you can see in <<cubic-bezier-method-figure>>, you# [online_only]#You# draw three lines that connect the endpoints and control points (a), and connect their midpoints. That produces two lines (b). You connect _their_ midpoints, and that produces one line (c), whose midpoint determines one of the points on the final curve.footnote:[We’re dispensing with the tent analogy; it gets too unwieldy. Curves based on yurts and geodesic domes are left as exercises for the reader.] 
Notice that the start, end, and middle angles of the curve are tangent to (they “follow”) the control lines.

[[cubic-bezier-method-figure]]

.Visualizing a cubic Bézier curve
image::images/sve2_0711.png[]

To specify such a cubic curve, use the +C+ or +c+ command.((("C or c command (cubic Bézier curves)"))) The command is followed by three sets of coordinates that specify the control point for the start point, the control point for the endpoint, and the endpoint. As with all the other path commands, an uppercase command implies absolute coordinates; lowercase implies relative coordinates. The curve in the preceding diagram was drawn from (20,80) to (200,120) with control points at (50,20) and (150,60). The SVG for the path was as follows:

----
<path d="M20 80 C 50 20, 150 60, 200 120"
    style="stroke: black; fill: none;"/>
----

There are many interesting curves you can draw, depending upon the relationship of the control points [offline_only]#(see <<cubic-bezier-figure>>)#. To make the graphic cleaner, we show only the lines from each endpoint to its control point. [online_only]#You can drag the control points to see how they modify the curve.#

[[cubic-bezier-figure]]
[role="offline_only"]
.Result of cubic Bézier control point combinations
image::images/sve2_0712.png[]

[role="offline_only"]
Experiment with these combinations and more in the online example:

[role="online_only"]
iframe::http://oreillymedia.github.io/svg-essentials-examples/ch07/cubic-bezier.html[width="100%", height="400px"]

As with quadratic curves, you can construct a cubic poly-Bézier by specifying several sets of coordinates after a cubic curve command. The last point of the first curve becomes the first point of the next curve, and so on. Here is a +<path>+ that draws a cubic curve from (30,100) to (100,100) with control points at (50,50) and (70,20); it is immediately followed by a curve that doubles back to (65,100) with control points at (110,130) and (45,150). Here is the SVG for this path, with control point coordinates in bold:

++++
<screen>&lt;path d="M30 100 C <emphasis role="strong">50 50</emphasis>, <emphasis role="strong">70 20</emphasis>, 100 100,
                  <emphasis role="strong">110, 130</emphasis>, <emphasis role="strong">45, 150</emphasis>, 65, 100"/&gt;</screen>
++++

The result is shown in the left half of <<cubic-polybezier-figure>>; the control points and lines are shown in the right half of the diagram.

[[cubic-polybezier-figure]]

.Cubic poly-Bézier curve
image::images/sve2_0713.png[]

If you want to guarantee a smooth join between curves, you ((("S or s command (smooth cubic Bézier curve)")))can use the +S+ command (or +s+ if you want to use relative coordinates).((("smooth cubic curve command"))) In a manner analogous to that of the +T+ command for quadratic curves, the new curve will take the previous curve’s endpoint as its starting point, and its first control point will be the reflection of the previous ending control point. All you need to supply is the control point for the next endpoint on the curve, followed by the next endpoint itself.

Here is a cubic Bézier curve drawn from (30,100) to (100,100) with control points at (50,30) and (70,50). It continues smoothly to (200,80), using (150,40) as its ending control point. The left half shows the curve; the right half shows curve with the control points. The reflected control point is shown with a dashed line in <<smooth-cubic-bezier-figure>>:

----
<path d="M30 100 C 50 30, 70 50, 100 100 S 150 40, 200 80"/>
----

[[smooth-cubic-bezier-figure]]
.Smooth cubic poly-Bézier curve
image::images/sve2_0714.png[]

[[path-reference-summary-section]]

=== Path Reference Summary

In <<path-reference-table>>, uppercase((("paths", "Bézier curves", range="endofrange", startref="ix_pathsBezier")))((("Bézier curves", range="endofrange", startref="ix_Bezier")))((("paths", "reference summary of commands")))((("elements", "reference tables", "path commands"))) commands use absolute coordinates, and lowercase commands use relative coordinates.

++++
<table id="path-reference-table">
<title>Path commands</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="15%"/>
<colspec colname="col_2" colwidth="26%"/>
<colspec colname="col_3" colwidth="46%"/>
<thead>
<row>
<entry>Command</entry>
<entry>Arguments</entry>
<entry>Effect</entry>
</row>
</thead>
<tbody>
<row>
<entry><simpara><literal>M</literal>
<literal>m</literal></simpara></entry>
<entry><simpara><emphasis><literal>x</literal></emphasis> <emphasis><literal>y</literal></emphasis></simpara></entry>
<entry><simpara>Move to given coordinates.</simpara></entry>
</row>
<row>
<entry><simpara><literal>L</literal>
<literal>l</literal></simpara></entry>
<entry><simpara><emphasis><literal>x</literal></emphasis> <emphasis><literal>y</literal></emphasis></simpara></entry>
<entry><simpara>Draw a line to the given coordinates. You may supply multiple sets of coordinates to draw a polyline.</simpara></entry>
</row>
<row>
<entry><simpara><literal>H</literal>
<literal>h</literal></simpara></entry>
<entry><simpara><emphasis><literal>x</literal></emphasis></simpara></entry>
<entry><simpara>Draw a horizontal line to the given <emphasis>x</emphasis>-coordinate.</simpara></entry>
</row>
<row>
<entry><simpara><literal>V</literal>
<literal>v</literal></simpara></entry>
<entry><simpara><emphasis><literal>y</literal></emphasis></simpara></entry>
<entry><simpara>Draw a vertical line to the given <emphasis>x</emphasis>-coordinate.</simpara></entry>
</row>
<row>
<entry><simpara><literal>A</literal>
<literal>a</literal></simpara></entry>
<entry><simpara><emphasis><literal>rx ry x-axis-rotation</literal></emphasis> <emphasis><literal>large-arc sweep x y</literal></emphasis></simpara></entry>
<entry><simpara>Draw an elliptical arc from the current point to (<emphasis><literal>x</literal></emphasis>,<emphasis><literal>y</literal></emphasis>). The points are on an ellipse with <emphasis>x</emphasis>-radius <emphasis><literal>rx</literal></emphasis> and <emphasis>y</emphasis>-radius <emphasis><literal>ry</literal></emphasis>. The ellipse is rotated <emphasis><literal>x-axis-rotation</literal></emphasis> degrees. If the arc is less than 180 degrees, <emphasis><literal>large-arc</literal></emphasis> is 0; if greater than 180 degrees, <emphasis><literal>large-arc</literal></emphasis> is 1. If the arc is to be drawn in the positive direction, <emphasis><literal>sweep</literal></emphasis> is 1; otherwise it is 0.</simpara></entry>
</row>
<row>
<entry><simpara><literal>Q</literal>
<literal>q</literal></simpara></entry>
<entry><simpara><emphasis><literal>x1 y1 x y</literal></emphasis></simpara></entry>
<entry><simpara>Draw a quadratic Bézier curve from the current point to (<emphasis><literal>x</literal></emphasis>,<emphasis><literal>y</literal></emphasis>) using control point (<emphasis><literal>x1</literal></emphasis>,<emphasis><literal>y1</literal></emphasis>).</simpara></entry>
</row>
<row>
<entry><simpara><literal>T</literal>
<literal>t</literal></simpara></entry>
<entry><simpara><emphasis><literal>x y</literal></emphasis></simpara></entry>
<entry><simpara>Draw a quadratic Bézier curve from the current point to (<emphasis><literal>x</literal></emphasis>,<emphasis><literal>y</literal></emphasis>). The control point will be the reflection of the previous <literal>Q</literal> command’s control point. If there is no previous curve, the current point will be used as the control point.</simpara></entry>
</row>
<row>
<entry><simpara><literal>C</literal>
<literal>c</literal></simpara></entry>
<entry><simpara><emphasis><literal>x1 y1 x2 y2 x y</literal></emphasis></simpara></entry>
<entry><simpara>Draw a cubic Bézier curve from the current point to (<emphasis><literal>x</literal></emphasis>,<emphasis><literal>y</literal></emphasis>) using control point (<emphasis><literal>x1</literal></emphasis>,<emphasis><literal>y1</literal></emphasis>) as the control point for the beginning of the curve and (<emphasis><literal>x2</literal></emphasis>,<emphasis><literal>y2</literal></emphasis>) as the control point for the endpoint of the curve.</simpara></entry>
</row>
<row>
<entry><simpara><literal>S</literal>
<literal>s</literal></simpara></entry>
<entry><simpara><emphasis><literal>x2 y2 x y</literal></emphasis></simpara></entry>
<entry><simpara>Draw a cubic Bézier curve from the current point to (<emphasis><literal>x</literal></emphasis>,<emphasis><literal>y</literal></emphasis>), using (<emphasis><literal>x2</literal></emphasis>,<emphasis><literal>y2</literal></emphasis>) as the control point for this new endpoint. The first control point will be the reflection of the previous <literal>C</literal> command’s ending control point. If there is no previous curve, the current point will be used as the first control point.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
++++


[[path-filling-section]]

=== Paths and Filling

The information described in <<basic-shapes-chapter>> in <<filling-polygons-section>> is also applicable to paths,((("fill-rule style", "for paths")))((("paths", "filling"))) which not only can have intersecting lines, but also can have “holes” in them. Consider the paths in <<path-filling-example>>, both of which draw nested squares. In the first path, both squares are drawn clockwise; in the second path, the outer square is drawn clockwise and the inner square is drawn pass:[<phrase role="keep-together">counterclockwise</phrase>].

[[path-filling-example]]
.Using different fill-rule values on paths

====
[source,xml]
----
<!-- both paths clockwise -->
<path d="M 0 0, 60 0, 60 60, 0 60 Z
    M 15 15, 45 15, 45 45, 15 45Z"/>

<!-- outer path clockwise; inner path counterclockwise -->
<path d="M 0 0, 60 0, 60 60, 0 60 Z
    M 15 15, 15 45, 45 45, 45 15Z"/>
----

====

<<path-filling-figure>> shows there is a difference when you use a +fill-rule+ of +nonzero+, which takes into account the direction of the lines when determining whether a point is inside or outside a path. Using a +fill-rule+ of +evenodd+ produces the same result for both paths; it uses total number of lines crossed and ignores their direction.

[[path-filling-figure]]

.Result of using different fill-rule values
image::images/sve2_0715.png[]

[[marker-section]]

=== The <marker> element

Consider the following path, which((("marker element", id="ix_marker", range="startofrange")))((("paths", "marker element", id="ix_pathsmarker", range="startofrange"))) uses a line, an elliptical arc, and another line to draw the rounded corner in <<plain-marker-figure>>:

[source,xml]
----
<path d="M 10 20 100 20 A 20 30 0 0 1 120 50 L 120 110"
    style="fill: none; stroke: black;"/>
----

[[plain-marker-figure]]

.Lines and arc
image::images/sve2_0716.png[]

Presume you want to mark the direction of the path by putting a circle at the beginning, a solid triangle at the end, and arrowheads at the other vertices, as shown in <<final-marker-figure>>. To achieve this effect, you need to construct three +<marker>+ elements and tell the +<path>+ to reference them.

[[final-marker-figure]]

.Lines and arc with markers
image::images/sve2_0717.png[]


As a first step, consider <<bad-circular-marker-example>>, which adds the circular marker. A marker is a “self-contained” graphic with its own private set of coordinates, so you have to specify its +markerWidth+ and +markerHeight+ in the starting +<marker>+ tag. That is followed by the SVG elements required to draw the marker, and ends with a closing +</marker>+. A +<marker>+ element does not display by itself, but we are putting it in a +<defs>+ element because that’s where reusable elements belong.

We want the circle to be at the beginning of the path, so we add((("marker element", "marker-start style"))) a +marker-start+ to the +style+ in the +<path>+.footnote:[Yes, markers are considered to be part of presentation rather than structure. This is one of those gray areas where you could argue either case.] The value of this property is a URL reference to the +<marker>+ element we’ve just created.


[[bad-circular-marker-example]]
.First attempt at circular marker

====
[language="xml"]
[subs="specialcharacters,quotes"]
----
<defs>
<marker id="mCircle" markerWidth="10" markerHeight="10">
    <circle cx="5" cy="5" r="4" style="fill: none; stroke: black;"/>
</marker>
</defs>

<path  d="M 10 20 100 20 A 20 30 0 0 1 120 50 L 120 110"
    style="marker-start: url(#mCircle);
    fill: none; stroke: black;"/>
----
====

The result in <<bad-circular-marker-figure>> is not quite what you planned...

[[bad-circular-marker-figure]]

.Misplaced circular marker
image::images/sve2_0718.png[]

The reason the circle appears in the wrong place is that, by default, the start marker’s (0,0) point is aligned with the beginning coordinate of the path. <<circular-marker-example>> adds +refX+ and +refY+ attributes specifying which coordinates (in the marker’s system) are to align with the beginning coordinate. Once these are added, the circular marker appears exactly where it is desired in <<circular-marker-figure>>.


[[circular-marker-example]]
.Correctly placed circular marker
====
[language="xml"]
[subs="specialcharacters,quotes"]
----
<marker id="mCircle" markerWidth="10" markerHeight="10"
        refX="5" refY="5">
    <circle cx="5" cy="5" r="4" style="fill: none; stroke: black;"/>
</marker>
----
====

[[circular-marker-figure]]

.Correctly placed circular marker
image::images/sve2_0719.png[]

Given this information, you can now write <<bad-multi-marker-example>>, which adds the triangular marker and references it as the +marker-end+ for the path.((("marker element", "marker-end style"))) Then we can add the arrowhead marker and ((("marker element", "marker-mid style")))reference it as the +marker-mid+. The +marker-mid+ will be attached to every vertex except the beginning and end of the path. Notice that the +refX+ and +refY+ attributes have been set so the wide end of the arrowhead aligns with the intermediate vertices, while the tip of the solid triangle aligns with the ending vertex. <<bad-multi-marker-figure>> shows the result, which draws the first marker correctly but not the others.

[[bad-multi-marker-example]]
.Attempt to use three markers
====
[language="xml"]
[subs="specialcharacters,quotes"]
----
<defs>
    <marker id="mCircle" markerWidth="10" markerHeight="10"
        refX="5" refY="5">
        <circle cx="5" cy="5" r="4" style="fill: none; stroke: black;"/>
    </marker>

    <marker id="mArrow" markerWidth="4" and markerHeight="8"
        refX="0" refY="4">
        <path d="M 0 0 4 4 0 8" style="fill: none; stroke: black;"/>
    </marker>

    <marker id="mTriangle" markerWidth="5" markerHeight="10"
        refX="5" refY="5">
        <path d="M 0 0 5 5 0 10 Z" style="fill: black;"/>
    </marker>
</defs>

<path d="M 10 20 100 20 A 20 30 0 0 1 120 50 L 120 110"
    style="marker-start: url(#mCircle);
        marker-mid: url(#mArrow);
        marker-end: url(#mTriangle);
        fill: none; stroke: black;"/>
----
====

[[bad-multi-marker-figure]]

.Incorrectly oriented markers
image::images/sve2_0720.png[]

To get the effect you want, you must explicitly set a marker’s +orient+ attribute to +auto+. ((("marker element", "orient attribute")))((("orient attribute, marker element")))This makes the marker automatically rotate to match the direction of the path.footnote:[To be exact, the rotation is the average of the angle of the direction of the line going into the vertex and the direction of the line going out of the vertex.] (You may also specify a number of degrees, in which case the marker will always be rotated by that amount.) Here in <<multi-marker-example>> are the markers, set to produce the effect shown in <<final-marker-figure>>. You don’t need to orient the circle; it looks the same no matter how it’s rotated.


[[multi-marker-example]]
.Correctly oriented markers
====
[language="xml"]
[subs="specialcharacters,quotes"]
----
<defs>
    <marker id="mCircle" markerWidth="10" markerHeight="10"
        refX="5" refY="5">
        <circle cx="5" cy="5" r="4" style="fill: none; stroke: black;"/>
    </marker>

    <marker id="mArrow" markerWidth="6" markerHeight="10"
        refX="0" refY="4" orient="auto">
        <path d="M 0 0 4 4 0 8" style="fill: none; stroke: black;"/>
    </marker>

    <marker id="mTriangle" markerWidth="5" markerHeight="10"
        refX="5" refY="5" orient="auto">
        <path d="M 0 0 5 5 0 10 Z" style="fill: black;"/>
    </marker>
</defs>

<path d="M 10 20 100 20 A 20 30 0 0 1 120 50 L 120 110"
    style="marker-start: url(#mCircle);
        marker-mid: url(#mArrow);
        marker-end: url(#mTriangle);
        fill: none; stroke: black;"/>
----
====

Another useful attribute is the +markerUnits+ attribute.((("markerUnits attribute, marker element"))) If set to +strokeWidth+, the marker’s coordinate system is set so one unit equals the stroke width. This makes your marker grow in proportion to the stroke width; it’s the default behavior and it’s usually what you want.((("userSpaceOnUse setting", "for markerUnits"))) If you set the attribute to +userSpaceOnUse+, the marker’s coordinates are presumed to be the same as the coordinate system of the object that references the marker. The marker will remain the same size irrespective of the stroke width.

[[marker-miscellanea-section]]

=== Marker Miscellanea

If you want the same marker at the beginning, middle, and end of a path, you don’t need to specify all of the +marker-start+, +marker-mid+, and +marker-end+ properties. Just use the +marker+ property and have it reference the marker you want. Thus, if you wanted all the vertices to have a circular marker, as shown in <<all-circular-markers-figure>>, you’d write the SVG in <<all-circular-markers-example>>.

[[all-circular-markers-example]]
.Using a single marker for all vertices

====
[source, xml]
----
<defs>
    <marker id="mCircle" markerWidth="10" markerHeight="10"
        refX="5" refY="5">
        <circle cx="5" cy="5" r="4" style="fill: none; stroke: black;"/>
    </marker>
</defs>

<path d="M 10 20 100 20 A 20 30 0 0 1 120 50 L 120 110"
    style="marker: url(#mCircle); fill: none; stroke: black;"/>
----

====

[[all-circular-markers-figure]]

.Using a single marker for all vertices
image::images/sve2_0721.png[]

It is also possible to set the +viewBox+ and +preserveAspectRatio+ attributes on a +<marker>+ element to gain even more control over its display.((("preserveAspectRatio attribute", "with marker element")))((("viewBox attribute", "marker element")))((("marker element", "setting viewBox and preserveAspectRatio to control display")))  For example, you can use a +viewBox+ to define the grid so that the (0,0) coordinate is in the center of your marker; you may want to do this instead of using +refX+ and +refY+. +viewBox+ and +preserveAspectRatio+ work exactly as described in <<user-coordinates-section>> and in <<preserve-aspect-ratio-section>>.

You may reference a +<marker>+ in a +<polygon>+, +<polyline>+, or +<line>+ element as well as in a +<path>+.

The following thought may have ((("nested markers")))occurred to you: “If a marker can have a path in it, can _that_ path have a marker attached to it as well?” The answer is yes, it can, but the second marker must fit into the rectangle established by the first marker’s +markerWidth+ and +markerHeight+. Remember that just because a thing can be done does not mean it should be done. If you need such an effect, you are probably better off to draw the secondary marker as a part of the primary marker rather than attempting to nest pass:[<phrase role="keep-together">markers</phrase>].

Make sure you don’t define a part of a marker to use itself as a marker. This could happen if you had a CSS rule like this to give all your paths a star as a marker:

[source,css]
----
path {marker: url(#star)}
----

If the +<marker>+ with id +star+ has a +<path>+ in it, that path would refer to itself in an infinite loop. To prevent this, you would add a CSS rule that says not to put any marker on a path that is part of the star marker:

[source,css]
----
path {marker: url(#star)}
marker#star path {marker: none}
----
((("paths", "marker element", range="endofrange", startref="ix_pathsmarker")))((("marker element", range="endofrange", startref="ix_marker")))((("paths", range="endofrange", startref="ix_paths07")))